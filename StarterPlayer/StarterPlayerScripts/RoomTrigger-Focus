-- PLAYER-FOLLOWING DYNAMIC CAMERA SYSTEM WITH FOV CONTROL
-- Place this in StarterPlayerScripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local roomEnterEvent = ReplicatedStorage:WaitForChild("PlayerEnteredRoom", 10)
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Base Camera Configuration
local BASE_CAMERA_HEIGHT = 25  -- Higher for better overview
local BASE_CAMERA_DISTANCE = 15  -- Further back for wider view
local CAMERA_SMOOTHNESS = 0.15  -- Smoother camera following (increased from 0.1)

-- FOV Configuration
local DEFAULT_FOV = 70          -- Default Roblox FOV is 70
local PLAYER_FOV = 85           -- Increased FOV for wider view (perfect for dungeons)
local FOV_MIN = 60              -- Minimum FOV allowed
local FOV_MAX = 100             -- Maximum FOV allowed
local FOV_STEP = 2              -- How much FOV changes per input

-- Player Camera Controls
local TILT_MIN = 0        -- Minimum tilt (top-down)
local TILT_MAX = 60       -- Maximum tilt (angled view)
local TILT_STEP = 1.0     -- How much each scroll changes tilt (reduced for smoother control)
local ZOOM_MIN = 0.4      -- Closest zoom (40% of base distance)
local ZOOM_MAX = 1.1      -- Maximum zoom (110% of base distance)
local ZOOM_STEP = 0.1     -- How much each R/F input changes zoom

-- Tilt smoothing configuration
local TILT_SMOOTHNESS = 0.12  -- How smoothly tilt changes (0.1 = smooth, 1 = instant)
local targetTilt = 60         -- Target tilt that we smooth towards
local currentTilt = 60        -- Current actual tilt value

-- Current player settings
local playerTilt = 60     -- Display tilt (for UI)
local playerZoom = 1.0    -- Default zoom level
local currentRoom = nil   -- Track which room player is in

-- Camera state
local targetCameraPosition = Vector3.new(0, 0, 0)
local currentCameraPosition = Vector3.new(0, 0, 0)
local isFollowingPlayer = false

-- Camera control state
local isDraggingCamera = false
local lastMousePosition = nil

-- Mobile touch control state
local isTouchTilting = false
local touchStartPosition = nil
local TOUCH_SENSITIVITY = 0.15  -- How sensitive touch dragging is

-- UI Configuration
local SHOW_CAMERA_UI = true

-- Detect if player is on mobile
local function isMobile()
	return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
end

print("üéÆ PLAYER-FOLLOWING CAMERA SYSTEM WITH FOV CONTROL INITIALIZING...")
print("üìê Default tilt:", playerTilt, "degrees")
print("üîç Default zoom:", playerZoom, "x")
print("üé• Default FOV:", PLAYER_FOV, "degrees")
print("üñ±Ô∏è Mouse wheel controls tilt with smooth interpolation")
print("üì± Mobile: Touch drag up/down for tilt control")
print("üë§ Camera will follow player smoothly with fixed orientation")

-- Calculate camera position relative to player (FIXED: Perfect centering with X/Y adjustment after 45¬∞)
local function calculatePlayerCameraPosition()
	if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
		return currentCameraPosition
	end

	local humanoidRootPart = player.Character.HumanoidRootPart
	local playerPosition = humanoidRootPart.Position

	-- Apply player zoom to distance
	local baseHeight = BASE_CAMERA_HEIGHT * playerZoom
	local baseDistance = BASE_CAMERA_DISTANCE * playerZoom

	-- Use smoothed tilt value for camera positioning
	local tiltRadians = math.rad(currentTilt)

	-- PERFECT CENTERING CALCULATION: Adjust position to keep player centered
	local heightComponent, distanceComponent, forwardOffset

	if currentTilt <= 45 then
		-- For angles 0-45¬∞: Use original calculation for smooth transition
		local totalDistance = baseDistance + baseHeight * math.tan(tiltRadians)
		heightComponent = totalDistance * math.sin(tiltRadians)
		distanceComponent = totalDistance * math.cos(tiltRadians)
		forwardOffset = 0  -- No offset needed in normal range
	else
		-- For angles >45¬∞: Lock distance/height but adjust position for perfect centering
		-- Calculate the values at exactly 45¬∞ as our baseline
		local tilt45Radians = math.rad(45)
		local totalDistanceAt45 = baseDistance + baseHeight * math.tan(tilt45Radians)
		local heightAt45 = totalDistanceAt45 * math.sin(tilt45Radians)
		local distanceAt45 = totalDistanceAt45 * math.cos(tilt45Radians)

		-- Lock the horizontal distance and use controlled height
		distanceComponent = distanceAt45
		local angleDifference = currentTilt - 45
		local gentleHeightGrowth = angleDifference * 0.3
		heightComponent = heightAt45 + gentleHeightGrowth

		-- CRITICAL FIX: Calculate forward offset to maintain perfect player centering
		-- As tilt increases, we need to move camera forward to keep player in center of view
		-- This offset compensates for the locked distance
		local expectedDistance = heightComponent / math.tan(tiltRadians)
		forwardOffset = distanceComponent - expectedDistance
	end

	-- Position camera with centering offset
	local cameraPosition = playerPosition + Vector3.new(0, heightComponent, distanceComponent - forwardOffset)

	return cameraPosition
end

-- Update camera to follow player smoothly with COMPLETELY FIXED orientation
local function updatePlayerFollowCamera()
	if not isFollowingPlayer then
		return
	end

	if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
		return
	end

	-- Smooth tilt interpolation
	currentTilt = currentTilt + (targetTilt - currentTilt) * TILT_SMOOTHNESS

	local humanoidRootPart = player.Character.HumanoidRootPart
	local playerPosition = humanoidRootPart.Position

	-- Calculate target camera position
	targetCameraPosition = calculatePlayerCameraPosition()

	-- Smoothly move camera towards target
	currentCameraPosition = currentCameraPosition:Lerp(targetCameraPosition, CAMERA_SMOOTHNESS)

	-- Set camera with COMPLETELY FIXED world orientation
	camera.CameraType = Enum.CameraType.Scriptable

	-- Set the FOV for wider view
	camera.FieldOfView = PLAYER_FOV

	-- Create completely fixed orientation using smoothed tilt
	local tiltRadians = math.rad(currentTilt)

	-- Fixed vectors that never rotate based on player position
	local fixedForward = Vector3.new(0, -math.sin(tiltRadians), -math.cos(tiltRadians))
	local fixedRight = Vector3.new(1, 0, 0)
	local fixedUp = fixedRight:Cross(fixedForward).Unit

	-- Create camera CFrame with completely fixed world orientation
	camera.CFrame = CFrame.fromMatrix(currentCameraPosition, fixedRight, fixedUp, -fixedForward)
end

-- Update camera view with new player settings
local function updateCameraView()
	if isFollowingPlayer then
		-- Update target tilt for smooth interpolation
		targetTilt = playerTilt

		-- Immediately recalculate target position with new settings
		targetCameraPosition = calculatePlayerCameraPosition()

		print("üîÑ Updated camera view:")
		print("üìê Tilt:", playerTilt, "¬∞ | üîç Zoom:", string.format("%.1f", playerZoom), "x | üé• FOV:", PLAYER_FOV, "¬∞")
	end
end

-- Set tilt with smooth animation
local function setTilt(newTilt)
	playerTilt = math.clamp(newTilt, TILT_MIN, TILT_MAX)
	targetTilt = playerTilt
	updateCameraUI()
end

-- Set FOV with limits
local function setFOV(newFOV)
	PLAYER_FOV = math.clamp(newFOV, FOV_MIN, FOV_MAX)
	updateCameraUI()
end

-- Handle mobile touch controls for tilt
local function handleTouchTilt(input, gameProcessed)
	if gameProcessed then return end

	if not isMobile() then return end

	if input.UserInputType == Enum.UserInputType.Touch then
		if input.UserInputState == Enum.UserInputState.Begin then
			-- Start touch tilt control
			isTouchTilting = true
			touchStartPosition = input.Position
			print("üì± Started touch tilt control")

		elseif input.UserInputState == Enum.UserInputState.Change and isTouchTilting then
			-- Handle touch drag for tilt
			if touchStartPosition then
				local deltaY = input.Position.Y - touchStartPosition.Y

				-- Calculate tilt change based on touch movement
				local tiltChange = deltaY * TOUCH_SENSITIVITY
				local newTilt = math.clamp(playerTilt - tiltChange, TILT_MIN, TILT_MAX)

				-- Only update if there's a meaningful change
				if math.abs(newTilt - playerTilt) > 0.1 then
					setTilt(newTilt)
					print("üì± Touch tilt:", string.format("%.1f", playerTilt), "degrees")
				end

				-- Update touch start position for continuous dragging
				touchStartPosition = input.Position
			end

		elseif input.UserInputState == Enum.UserInputState.End and isTouchTilting then
			-- End touch tilt control
			isTouchTilting = false
			touchStartPosition = nil
			print("üì± Ended touch tilt control")
		end
	end
end

-- Start following player
local function startFollowingPlayer()
	print("üë§ STARTING PLAYER FOLLOW MODE...")

	if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		-- Initialize camera position and tilt values
		currentTilt = playerTilt
		targetTilt = playerTilt
		currentCameraPosition = calculatePlayerCameraPosition()
		targetCameraPosition = currentCameraPosition
		isFollowingPlayer = true

		print("‚úÖ Now following player with smooth controls")
		print("üìê Tilt:", playerTilt, "¬∞ | üîç Zoom:", string.format("%.1f", playerZoom), "x | üé• FOV:", PLAYER_FOV, "¬∞")
		if isMobile() then
			print("üì± Mobile detected: Touch drag up/down for tilt control")
		end
	else
		print("‚ùå Player character not found!")
	end
end

-- Handle camera controls with keyboard
local function handleCameraControls(input, gameProcessed)
	if gameProcessed then return end

	local changed = false

	-- Middle mouse button drag for tilt control (backup method for PC)
	if input.UserInputType == Enum.UserInputType.MouseButton3 then
		isDraggingCamera = true
		lastMousePosition = UserInputService:GetMouseLocation()
		print("üñ±Ô∏è Started camera drag")

		-- Zoom controls (R/F)
	elseif input.KeyCode == Enum.KeyCode.R then
		playerZoom = math.min(playerZoom + ZOOM_STEP, ZOOM_MAX)
		print("üîç ZOOMED OUT to:", string.format("%.1f", playerZoom), "x")
		changed = true

	elseif input.KeyCode == Enum.KeyCode.F then
		playerZoom = math.max(playerZoom - ZOOM_STEP, ZOOM_MIN)
		print("üîç ZOOMED IN to:", string.format("%.1f", playerZoom), "x")
		changed = true

		-- FOV controls (Y/U keys)
	elseif input.KeyCode == Enum.KeyCode.U then
		setFOV(PLAYER_FOV + FOV_STEP)
		print("üé• FOV INCREASED to:", PLAYER_FOV, "degrees")
		changed = true

	elseif input.KeyCode == Enum.KeyCode.Y then
		setFOV(PLAYER_FOV - FOV_STEP)
		print("üé• FOV DECREASED to:", PLAYER_FOV, "degrees")
		changed = true

		-- Reset to defaults
	elseif input.KeyCode == Enum.KeyCode.T then
		setTilt(60)  -- Use smooth tilt function
		playerZoom = 1.0
		setFOV(85)  -- Reset FOV to default
		print("üîÑ RESET camera to defaults: Tilt =", playerTilt, "¬∞, Zoom =", playerZoom, "x, FOV =", PLAYER_FOV, "¬∞")
		changed = true

		-- Toggle camera smoothness
	elseif input.KeyCode == Enum.KeyCode.G then
		if CAMERA_SMOOTHNESS == 0.15 then
			CAMERA_SMOOTHNESS = 0.08  -- More smooth
			TILT_SMOOTHNESS = 0.08
			print("üêå SMOOTHER camera follow")
		elseif CAMERA_SMOOTHNESS == 0.08 then
			CAMERA_SMOOTHNESS = 0.25   -- Less smooth
			TILT_SMOOTHNESS = 0.25
			print("üêá FASTER camera follow")
		else
			CAMERA_SMOOTHNESS = 0.15   -- Default
			TILT_SMOOTHNESS = 0.12
			print("‚öñÔ∏è DEFAULT camera follow")
		end
	end

	-- Update camera if settings changed
	if changed then
		updateCameraView()
		updateCameraUI()
	end
end

-- Handle middle mouse drag for camera tilt (PC backup method)
local function handleMouseDrag(input, gameProcessed)
	if gameProcessed then return end

	if input.UserInputType == Enum.UserInputType.MouseMovement and isDraggingCamera then
		local currentMousePosition = UserInputService:GetMouseLocation()

		if lastMousePosition then
			local deltaY = currentMousePosition.Y - lastMousePosition.Y
			local sensitivity = 0.15  -- Reduced for smoother control
			local tiltChange = deltaY * sensitivity

			setTilt(playerTilt + tiltChange)
			print("üé• Mouse drag tilt:", string.format("%.1f", playerTilt), "degrees")
		end

		lastMousePosition = currentMousePosition
	end
end

-- Handle mouse button release
local function handleMouseRelease(input, gameProcessed)
	if gameProcessed then return end

	if input.UserInputType == Enum.UserInputType.MouseButton3 then
		isDraggingCamera = false
		lastMousePosition = nil
		print("üñ±Ô∏è Stopped camera drag")
	end
end

-- Handle mouse wheel for TILT control (smooth PC method)
local function handleMouseWheel(input, gameProcessed)
	if gameProcessed then return end

	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local delta = input.Position.Z

		if delta > 0 then
			-- Scroll up = Increase tilt (more angled view)
			setTilt(playerTilt + TILT_STEP)
			print("üñ±Ô∏è MOUSE WHEEL: Tilt INCREASED to:", string.format("%.1f", playerTilt), "degrees")
		else
			-- Scroll down = Decrease tilt (more top-down view)
			setTilt(playerTilt - TILT_STEP)
			print("üñ±Ô∏è MOUSE WHEEL: Tilt DECREASED to:", string.format("%.1f", playerTilt), "degrees")
		end
	end
end

-- Create on-screen camera controls UI
local function createCameraUI()
	if not SHOW_CAMERA_UI then return end

	local playerGui = player:WaitForChild("PlayerGui")

	-- Create UI
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "CameraControlsUI"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = playerGui

	-- Main frame (made taller for FOV display)
	local frame = Instance.new("Frame")
	frame.Name = "CameraFrame"
	frame.Size = UDim2.new(0, 220, 0, 160)
	frame.Position = UDim2.new(1, -230, 0, 10)  -- Top right
	frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	frame.BackgroundTransparency = 0.3
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	-- Corner radius
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = frame

	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, 0, 0, 25)
	title.Position = UDim2.new(0, 0, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "üë§ Player Camera"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.TextScaled = true
	title.Font = Enum.Font.SourceSansBold
	title.Parent = frame

	-- Mode display
	local modeLabel = Instance.new("TextLabel")
	modeLabel.Name = "ModeLabel"
	modeLabel.Size = UDim2.new(1, -10, 0, 20)
	modeLabel.Position = UDim2.new(0, 5, 0, 25)
	modeLabel.BackgroundTransparency = 1
	modeLabel.Text = "üéØ Fixed World Orientation"
	modeLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	modeLabel.TextScaled = true
	modeLabel.Font = Enum.Font.SourceSans
	modeLabel.TextXAlignment = Enum.TextXAlignment.Left
	modeLabel.Parent = frame

	-- Tilt display
	local tiltLabel = Instance.new("TextLabel")
	tiltLabel.Name = "TiltLabel"
	tiltLabel.Size = UDim2.new(1, -10, 0, 20)
	tiltLabel.Position = UDim2.new(0, 5, 0, 50)
	tiltLabel.BackgroundTransparency = 1
	tiltLabel.Text = "üìê Tilt: " .. string.format("%.1f", playerTilt) .. "¬∞ (Mouse Wheel)"
	tiltLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	tiltLabel.TextScaled = true
	tiltLabel.Font = Enum.Font.SourceSans
	tiltLabel.TextXAlignment = Enum.TextXAlignment.Left
	tiltLabel.Parent = frame

	-- Zoom display
	local zoomLabel = Instance.new("TextLabel")
	zoomLabel.Name = "ZoomLabel"
	zoomLabel.Size = UDim2.new(1, -10, 0, 20)
	zoomLabel.Position = UDim2.new(0, 5, 0, 75)
	zoomLabel.BackgroundTransparency = 1
	zoomLabel.Text = "üîç Zoom: " .. string.format("%.1f", playerZoom) .. "x (R/F)"
	zoomLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	zoomLabel.TextScaled = true
	zoomLabel.Font = Enum.Font.SourceSans
	zoomLabel.TextXAlignment = Enum.TextXAlignment.Left
	zoomLabel.Parent = frame

	-- FOV display
	local fovLabel = Instance.new("TextLabel")
	fovLabel.Name = "FOVLabel"
	fovLabel.Size = UDim2.new(1, -10, 0, 20)
	fovLabel.Position = UDim2.new(0, 5, 0, 100)
	fovLabel.BackgroundTransparency = 1
	fovLabel.Text = "üé• FOV: " .. PLAYER_FOV .. "¬∞ (Y/U)"
	fovLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	fovLabel.TextScaled = true
	fovLabel.Font = Enum.Font.SourceSans
	fovLabel.TextXAlignment = Enum.TextXAlignment.Left
	fovLabel.Parent = frame

	-- Instructions (updated for FOV controls)
	local instructions = Instance.new("TextLabel")
	instructions.Name = "Instructions"
	instructions.Size = UDim2.new(1, -10, 0, 50)
	instructions.Position = UDim2.new(0, 5, 0, 125)
	instructions.BackgroundTransparency = 1
	if isMobile() then
		instructions.Text = "üì± Touch Drag: Tilt\nR/F: Zoom\nT: Reset"
	else
		instructions.Text = "Mouse Wheel: Tilt | R/F: Zoom\nY/U: FOV | Middle Drag: Tilt\nT: Reset | G: Smoothness"
	end
	instructions.TextColor3 = Color3.fromRGB(150, 150, 150)
	instructions.TextScaled = true
	instructions.Font = Enum.Font.SourceSans
	instructions.TextXAlignment = Enum.TextXAlignment.Left
	instructions.Parent = frame

	return screenGui
end

-- Update camera UI display
function updateCameraUI()
	local ui = player.PlayerGui:FindFirstChild("CameraControlsUI")
	if not ui then return end

	local frame = ui:FindFirstChild("CameraFrame")
	if not frame then return end

	local tiltLabel = frame:FindFirstChild("TiltLabel")
	local zoomLabel = frame:FindFirstChild("ZoomLabel")
	local fovLabel = frame:FindFirstChild("FOVLabel")

	if tiltLabel then
		if isMobile() then
			tiltLabel.Text = "üìê Tilt: " .. string.format("%.1f", playerTilt) .. "¬∞ (Touch Drag)"
		else
			tiltLabel.Text = "üìê Tilt: " .. string.format("%.1f", playerTilt) .. "¬∞ (Mouse Wheel)"
		end
	end

	if zoomLabel then
		zoomLabel.Text = "üîç Zoom: " .. string.format("%.1f", playerZoom) .. "x (R/F)"
	end

	if fovLabel then
		fovLabel.Text = "üé• FOV: " .. PLAYER_FOV .. "¬∞ (Y/U)"
	end
end

-- Check which room player is in (for enemy spawning)
local function checkCurrentRoom()
	if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
		return
	end

	local humanoidRootPart = player.Character.HumanoidRootPart
	local playerPosition = humanoidRootPart.Position

	local triggers = CollectionService:GetTagged("RoomTrigger")

	for _, trigger in pairs(triggers) do
		local triggerPosition = trigger.Position
		local triggerSize = trigger.Size

		local minBounds = triggerPosition - (triggerSize / 2)
		local maxBounds = triggerPosition + (triggerSize / 2)

		local inTrigger = playerPosition.X >= minBounds.X and playerPosition.X <= maxBounds.X and
			playerPosition.Y >= minBounds.Y and playerPosition.Y <= maxBounds.Y and
			playerPosition.Z >= minBounds.Z and playerPosition.Z <= maxBounds.Z

		if inTrigger then
			local roomID = trigger:GetAttribute("RoomID")

			if roomID and currentRoom ~= roomID then
				currentRoom = roomID
				print("üö™ ENTERED ROOM:", roomID, "(camera following player)")

				-- Send room change to server via RemoteEvent
				if roomEnterEvent then
					roomEnterEvent:FireServer(roomID)
					print("üì° Sent room change to server:", roomID)
				else
					print("‚ùå RemoteEvent not found")
				end
			end

			return
		end
	end
end

-- Handle character spawning
local function onCharacterAdded(character)
	print("üë§ CHARACTER SPAWNED - Starting player follow camera...")

	-- Wait for character to be fully loaded
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

	-- Small delay to ensure character is positioned
	task.wait(0.1)

	-- Start following the player
	startFollowingPlayer()
end

-- Initialize player-following camera system
local function initializePlayerCamera()
	print("üöÄ INITIALIZING PLAYER-FOLLOWING CAMERA SYSTEM WITH FOV CONTROL...")

	-- Connect input handlers
	UserInputService.InputBegan:Connect(handleCameraControls)
	UserInputService.InputBegan:Connect(handleTouchTilt)  -- Mobile touch support
	UserInputService.InputChanged:Connect(handleMouseWheel)
	UserInputService.InputChanged:Connect(handleMouseDrag)
	UserInputService.InputChanged:Connect(handleTouchTilt)  -- Mobile touch dragging
	UserInputService.InputEnded:Connect(handleMouseRelease)
	UserInputService.InputEnded:Connect(handleTouchTilt)  -- Mobile touch end

	-- Create UI
	createCameraUI()

	-- Connect to character spawning
	if player.Character then
		onCharacterAdded(player.Character)
	end
	player.CharacterAdded:Connect(onCharacterAdded)

	-- Start camera update loop
	RunService.Heartbeat:Connect(function()
		updatePlayerFollowCamera()
		checkCurrentRoom()
	end)

	print("‚úÖ Player-Following Camera System with FOV Control loaded!")
	print("üéÆ CONTROLS:")
	if isMobile() then
		print("  üì± Touch Drag Up/Down - Adjust camera tilt (MOBILE)")
		print("  R/F - Zoom in/out (if available)")
		print("  T - Reset to defaults (if available)")
	else
		print("  üñ±Ô∏è Mouse Wheel - Adjust camera tilt (PRIMARY METHOD)")
		print("  üñ±Ô∏è Middle Mouse Drag - Adjust camera tilt (backup)")
		print("  R/F - Zoom in/out") 
		print("  Y/U - Adjust FOV (Field of View)")
		print("  T - Reset to defaults")
		print("  G - Toggle camera smoothness")
	end
	print("üë§ Camera will smoothly follow player movement")
	print("üé• FOV set to", PLAYER_FOV, "degrees for better dungeon view!")
end

initializePlayerCamera()
