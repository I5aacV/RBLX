-- CLEAN ISAAC SHOOTING SYSTEM - BUILT FROM SCRATCH
-- Place this in StarterPlayerScripts

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()

-- ATTACK SYSTEM CONFIGURATION (Easy to modify for different attacks)
local ATTACK_CONFIGS = {
	BasicTear = {
		-- Damage and Speed
		damage = 10,
		speed = 40,           -- Studs per second (affects distance traveled)
		fireRate = 0.25,      -- Seconds between shots
		lifetime = 2.0,       -- How long orb exists (affects max distance)

		-- Visual Properties (all configurable)
		sizeX = 1,          -- Width of projectile
		sizeY = 1,          -- Height of projectile  
		sizeZ = 1,          -- Depth of projectile
		colorR = 100,         -- Red component (0-255)
		colorG = 150,         -- Green component (0-255)
		colorB = 255,         -- Blue component (0-255)
		material = Enum.Material.Neon,
		transparency = 0.1,   -- 0 = opaque, 1 = invisible

		-- Physics
		gravity = -20,        -- Downward acceleration (affects arc)
		spawnOffset = 2,      -- Distance from player when spawned
		spawnHeight = 1.2,    -- Height above player

		-- Effects
		hasTrail = true,
		hasGlow = true,
		glowBrightness = 2,
		glowRange = 10
	}
}

-- CURRENT ATTACK (can be changed for different characters/powerups)
local currentAttack = "BasicTear"

-- INPUT CONFIGURATION
local CONTROLS = {
	-- Movement keys (for aiming only - don't interfere with character movement)
	up = {Enum.KeyCode.W, Enum.KeyCode.Up},
	down = {Enum.KeyCode.S, Enum.KeyCode.Down},
	left = {Enum.KeyCode.A, Enum.KeyCode.Left},
	right = {Enum.KeyCode.D, Enum.KeyCode.Right},

	-- Shooting
	shoot = Enum.UserInputType.MouseButton1
}

-- SHOOTING SYSTEM
local ShootingSystem = {}
ShootingSystem.__index = ShootingSystem

function ShootingSystem.new()
	local self = setmetatable({}, ShootingSystem)

	-- System state
	self.activeProjectiles = {}
	self.lastShotTime = 0
	self.aimDirection = Vector3.new(0, 0, -1)  -- Default: forward

	-- Input tracking (for 8-directional aiming)
	self.inputState = {
		up = false,
		down = false,
		left = false,
		right = false
	}

	-- Initialize
	self:setupInput()
	self:startProjectileLoop()

	print("üéØ Clean Isaac Shooting System loaded!")
	print("üéÆ WASD/Arrows to aim (8 directions), Left Click to shoot")
	print("‚ö° Zero interference with player movement!")

	return self
end

-- Setup input handling (aiming only - no character movement interference)
function ShootingSystem:setupInput()
	-- Key press detection
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end

		-- Track directional keys for aiming
		self:updateInputState(input.KeyCode, true)

		-- Handle shooting
		if input.UserInputType == CONTROLS.shoot then
			self:shoot()
		end
	end)

	-- Key release detection
	UserInputService.InputEnded:Connect(function(input, gameProcessed)
		if gameProcessed then return end

		self:updateInputState(input.KeyCode, false)
	end)
end

-- Update input state and calculate aim direction
function ShootingSystem:updateInputState(keyCode, pressed)
	-- Check if this key is mapped to a direction
	for direction, keys in pairs(CONTROLS) do
		if direction ~= "shoot" then
			for _, mappedKey in pairs(keys) do
				if keyCode == mappedKey then
					self.inputState[direction] = pressed
					self:calculateAimDirection()
					return
				end
			end
		end
	end
end

-- Calculate 8-directional aim from input state
function ShootingSystem:calculateAimDirection()
	local x, z = 0, 0

	-- Calculate direction vector from input
	if self.inputState.up then z = z - 1 end
	if self.inputState.down then z = z + 1 end
	if self.inputState.left then x = x - 1 end
	if self.inputState.right then x = x + 1 end

	-- Update aim direction (only if there's input)
	if x ~= 0 or z ~= 0 then
		self.aimDirection = Vector3.new(x, 0, z).Unit
	end
end

-- Shoot a projectile
function ShootingSystem:shoot()
	local config = ATTACK_CONFIGS[currentAttack]
	if not config then return end

	-- Check fire rate
	local currentTime = tick()
	if currentTime - self.lastShotTime < config.fireRate then
		return
	end

	-- Get player position
	if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
		return
	end

	local humanoidRootPart = player.Character.HumanoidRootPart
	local playerPos = humanoidRootPart.Position

	-- Calculate spawn position (offset from player)
	local spawnPos = playerPos + 
		Vector3.new(0, config.spawnHeight, 0) + 
		self.aimDirection * config.spawnOffset

	-- Create projectile
	local projectile = self:createProjectile(spawnPos, self.aimDirection, config)
	table.insert(self.activeProjectiles, projectile)

	-- Update fire rate timer
	self.lastShotTime = currentTime

	print("üíô Shot projectile in direction:", self:getDirectionName(self.aimDirection))
end

-- Create a projectile with the given configuration
function ShootingSystem:createProjectile(position, direction, config)
	print("üî® Creating projectile at position:", position)
	print("üî® Direction:", direction)

	-- Create visual projectile
	local projectilePart = Instance.new("Part")
	projectilePart.Name = "Projectile_" .. currentAttack
	projectilePart.Size = Vector3.new(config.sizeX, config.sizeY, config.sizeZ)
	projectilePart.Color = Color3.fromRGB(config.colorR, config.colorG, config.colorB)
	projectilePart.Material = config.material
	projectilePart.Transparency = config.transparency
	projectilePart.Shape = Enum.PartType.Ball
	projectilePart.CanCollide = true   -- FIXED: Need this for Touched events
	projectilePart.Anchored = false    -- FIXED: Use BodyVelocity instead
	projectilePart.Position = position
	projectilePart.Parent = workspace

	-- Create BodyVelocity for smooth movement without collision interference
	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
	bodyVelocity.Velocity = direction * config.speed
	bodyVelocity.Parent = projectilePart

	-- Create BodyPosition to prevent physics interference with player
	local bodyPosition = Instance.new("BodyPosition")
	bodyPosition.MaxForce = Vector3.new(0, 4000, 0)  -- Only affect Y axis for gravity
	bodyPosition.Position = position
	bodyPosition.P = 3000
	bodyPosition.D = 500
	bodyPosition.Parent = projectilePart

	print("üî® Projectile created with properties:")
	print("   Name:", projectilePart.Name)
	print("   Size:", projectilePart.Size)
	print("   CanCollide:", projectilePart.CanCollide)
	print("   Anchored:", projectilePart.Anchored)
	print("   Parent:", projectilePart.Parent and projectilePart.Parent.Name or "No parent")

	-- Add visual effects
	if config.hasGlow then
		local pointLight = Instance.new("PointLight")
		pointLight.Color = Color3.fromRGB(config.colorR, config.colorG, config.colorB)
		pointLight.Brightness = config.glowBrightness
		pointLight.Range = config.glowRange
		pointLight.Parent = projectilePart
	end

	if config.hasTrail then
		local attachment = Instance.new("Attachment")
		attachment.Parent = projectilePart

		local trail = Instance.new("Trail")
		trail.Attachment0 = attachment
		trail.Attachment1 = attachment
		trail.Color = ColorSequence.new(Color3.fromRGB(config.colorR, config.colorG, config.colorB))
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.3),
			NumberSequenceKeypoint.new(1, 1)
		})
		trail.Lifetime = 0.5
		trail.MinLength = 0
		trail.Parent = projectilePart
	end

	-- Projectile data
	local projectileData = {
		part = projectilePart,
		bodyVelocity = bodyVelocity,
		bodyPosition = bodyPosition,
		config = config,

		-- Physics
		initialDirection = direction,
		currentVelocity = direction * config.speed,

		-- Metadata
		startTime = tick(),
		damage = config.damage,
		hasHit = false
	}

	-- Setup hit detection
	self:setupHitDetection(projectileData)

	return projectileData
end

-- Setup hit detection for projectile
function ShootingSystem:setupHitDetection(projectileData)
	local part = projectileData.part

	print("üîó Setting up hit detection for:", part.Name)

	-- Use Touched event for simple, reliable hit detection
	local connection = part.Touched:Connect(function(hitPart)
		print("üí• ORB TOUCHED SOMETHING:", hitPart.Name, "(" .. hitPart.ClassName .. ")")

		-- Prevent multiple hits
		if projectileData.hasHit then 
			print("üö´ Already hit something, ignoring")
			return 
		end

		-- Don't hit the player who shot it
		if player.Character then
			for _, playerPart in pairs(player.Character:GetDescendants()) do
				if playerPart == hitPart then 
					print("üö´ Ignoring hit on player part:", hitPart.Name)
					return 
				end
			end
		end

		-- Don't hit other projectiles
		if string.find(hitPart.Name, "Projectile_") then 
			print("üö´ Ignoring hit on other projectile:", hitPart.Name)
			return 
		end

		-- Check for enemy hit
		if self:isEnemy(hitPart) then
			print("üéØ ENEMY HIT CONFIRMED! Processing damage...")
			projectileData.hasHit = true
			self:handleEnemyHit(hitPart, projectileData)
			return
		end

		-- Check for solid obstacles
		if self:isSolidObstacle(hitPart) then
			print("üß± OBSTACLE HIT:", hitPart.Name)
			projectileData.hasHit = true
			self:handleObstacleHit(hitPart, projectileData)
			return
		end

		print("üëª Hit something else (ignoring):", hitPart.Name)
	end)

	print("üîó Hit detection connected for:", part.Name)

	-- Store connection for cleanup
	projectileData.hitConnection = connection
end

-- Check if part belongs to an enemy
function ShootingSystem:isEnemy(part)
	-- Debug what we're checking
	print("üîç Checking if enemy:", part.Name, "(" .. part.ClassName .. ")")

	-- Check if part or its parent has enemy tag
	if CollectionService:HasTag(part, "RoomEnemy") then
		print("‚úÖ Part itself has RoomEnemy tag")
		return true
	end
	if part.Parent and CollectionService:HasTag(part.Parent, "RoomEnemy") then
		print("‚úÖ Parent has RoomEnemy tag")
		return true
	end

	-- Check for any enemy-related tags (debug)
	local tags = CollectionService:GetTags(part)
	local parentTags = part.Parent and CollectionService:GetTags(part.Parent) or {}

	print("üè∑Ô∏è Part tags:", table.concat(tags, ", "))
	if part.Parent then
		print("üè∑Ô∏è Parent tags:", table.concat(parentTags, ", "))
	end

	-- Look for common enemy indicators
	if string.find(string.lower(part.Name), "enemy") or 
		string.find(string.lower(part.Name), "fly") or
		string.find(string.lower(part.Name), "spider") or
		string.find(string.lower(part.Name), "gaper") then
		print("‚úÖ Found enemy by name pattern")
		return true
	end

	if part.Parent then
		local parentName = string.lower(part.Parent.Name)
		if string.find(parentName, "enemy") or 
			string.find(parentName, "fly") or
			string.find(parentName, "spider") or
			string.find(parentName, "gaper") then
			print("‚úÖ Found enemy by parent name pattern")
			return true
		end
	end

	print("‚ùå Not recognized as enemy")
	return false
end

-- Check if part is a solid obstacle
function ShootingSystem:isSolidObstacle(part)
	-- Check for tagged obstacles
	if CollectionService:HasTag(part, "RoomWall") or
		CollectionService:HasTag(part, "RoomObstacle") or
		CollectionService:HasTag(part, "DamageSpike") then
		return true
	end

	-- Check for solid parts (basic collision)
	if part.CanCollide and part.Transparency < 0.8 and part.Size.Magnitude > 2 then
		return true
	end

	return false
end

-- REPLACE THIS FUNCTION: handleEnemyHit
function ShootingSystem:handleEnemyHit(hitPart, projectileData)
	print("üéØ Processing enemy hit on:", hitPart.Name)

	-- Find the enemy model (improved hierarchy search)
	local enemy = nil
	local searchPart = hitPart

	-- Search up the hierarchy for enemy tag
	while searchPart and searchPart ~= workspace do
		if CollectionService:HasTag(searchPart, "RoomEnemy") then
			enemy = searchPart
			print("‚úÖ Found enemy via tag:", enemy.Name)
			break
		end
		searchPart = searchPart.Parent
	end

	-- Fallback: Check if hit part itself or parent has enemy name patterns
	if not enemy then
		if self:hasEnemyNamePattern(hitPart) then
			enemy = hitPart
		elseif hitPart.Parent and self:hasEnemyNamePattern(hitPart.Parent) then
			enemy = hitPart.Parent
		end
	end

	if not enemy then
		print("‚ùå No enemy found for hit part:", hitPart.Name)
		return
	end

	-- Find Humanoid in the enemy
	local humanoid = enemy:FindFirstChild("Humanoid")
	if not humanoid then
		humanoid = enemy:FindFirstChildOfClass("Humanoid")
		if not humanoid then
			print("‚ùå No Humanoid found in enemy:", enemy.Name)
			return
		end
	end

	-- Check if enemy is already dead
	if humanoid.Health <= 0 then
		print("üíÄ Enemy already dead, ignoring hit")
		return
	end

	-- IMPROVED DAMAGE DEALING: More reliable death triggering
	local oldHealth = humanoid.Health
	local damage = projectileData.damage
	local newHealth = math.max(0, oldHealth - damage)

	print("üí• Dealing damage to", enemy.Name)
	print("  üíñ Health before:", oldHealth)
	print("  ‚öîÔ∏è Damage:", damage)
	print("  üíñ Health after:", newHealth)

	-- Set the new health
	humanoid.Health = newHealth

	-- CRITICAL FIX: Ensure death event fires properly
	if newHealth <= 0 and oldHealth > 0 then
		print("üíÄ Enemy should die! Ensuring death event fires...")

		-- Wait a tiny bit for natural death event
		task.wait(0.05)

		-- If enemy still isn't marked as dying, force it
		if not enemy:GetAttribute("DeathProcessed") then
			print("üî• Forcing death event for:", enemy.Name)
			-- Set health to exactly 0 to trigger Died event
			humanoid.Health = 0

			-- If that doesn't work, we'll rely on the backup health monitoring
			-- in the enemy spawner system
		end
	end

	-- Create visual feedback
	self:createHitEffect(projectileData.part.Position, "enemy")
	self:createDamageNumber(enemy, damage)

	print("‚úÖ Hit processing complete for:", enemy.Name)
end

-- ADD THIS HELPER FUNCTION: hasEnemyNamePattern
function ShootingSystem:hasEnemyNamePattern(part)
	if not part or not part.Name then return false end

	local name = string.lower(part.Name)
	local enemyPatterns = {"enemy", "fly", "spider", "gaper", "monster", "mob"}

	for _, pattern in pairs(enemyPatterns) do
		if string.find(name, pattern) then
			return true
		end
	end

	return false
end

-- Handle obstacle hit
function ShootingSystem:handleObstacleHit(hitPart, projectileData)
	-- Create hit effect
	self:createHitEffect(projectileData.part.Position, "wall")


	print("üí® Hit obstacle")
end

-- Create floating damage number
-- Create floating damage number
function ShootingSystem:createDamageNumber(enemy, damage)
	-- Find a good position above the enemy
	local enemyPosition = nil

	-- Try different ways to get the enemy position
	if enemy:FindFirstChild("HumanoidRootPart") then
		enemyPosition = enemy.HumanoidRootPart.Position
		print("üìç Using HumanoidRootPart position")
	elseif enemy:FindFirstChild("Torso") then
		enemyPosition = enemy.Torso.Position
		print("üìç Using Torso position")
	elseif enemy:FindFirstChild("UpperTorso") then
		enemyPosition = enemy.UpperTorso.Position
		print("üìç Using UpperTorso position")
	elseif enemy.PrimaryPart then
		enemyPosition = enemy.PrimaryPart.Position
		print("üìç Using PrimaryPart position")
	else
		-- Find any Part in the enemy model
		for _, child in pairs(enemy:GetChildren()) do
			if child:IsA("BasePart") then
				enemyPosition = child.Position
				print("üìç Using first BasePart position:", child.Name)
				break
			end
		end
	end

	-- If we still can't find a position, use a default
	if not enemyPosition then
		print("‚ùå Could not find enemy position! Using default.")
		enemyPosition = Vector3.new(0, 0, 0)
	end

	-- Create the damage number GUI
	local damageGui = Instance.new("BillboardGui")
	damageGui.Name = "DamageNumber"
	damageGui.Size = UDim2.new(0, 100, 0, 50)
	damageGui.StudsOffset = Vector3.new(0, 3, 0)
	damageGui.Adornee = enemy
	damageGui.Parent = workspace

	-- Create the text label
	local damageLabel = Instance.new("TextLabel")
	damageLabel.Name = "DamageText"
	damageLabel.Size = UDim2.new(1, 0, 1, 0)
	damageLabel.BackgroundTransparency = 1
	damageLabel.Text = "-" .. tostring(damage)
	damageLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	damageLabel.TextScaled = true
	damageLabel.TextStrokeTransparency = 0
	damageLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	damageLabel.Font = Enum.Font.SourceSansBold
	damageLabel.Parent = damageGui

	-- Animate the damage number
	local TweenService = game:GetService("TweenService")
	local Debris = game:GetService("Debris")

	-- Float up and fade out
	local tweenInfo = TweenInfo.new(
		1.5,  -- Duration
		Enum.EasingStyle.Quad,
		Enum.EasingDirection.Out,
		0,    -- Repeat count
		false -- Reverse
	)

	local tween = TweenService:Create(damageGui, tweenInfo, {
		StudsOffset = Vector3.new(0, 6, 0)
	})

	local fadeTween = TweenService:Create(damageLabel, tweenInfo, {
		TextTransparency = 1,
		TextStrokeTransparency = 1
	})

	-- Start animations
	tween:Play()
	fadeTween:Play()

	-- Clean up after animation
	Debris:AddItem(damageGui, 1.5)

	print("üìä Created damage number:", damage, "at position:", enemyPosition)
end

-- Create visual hit effect
function ShootingSystem:createHitEffect(position, hitType)
	local effect = Instance.new("Part")
	effect.Name = "HitEffect"
	effect.Size = Vector3.new(1.5, 1.5, 1.5)
	effect.Shape = Enum.PartType.Ball
	effect.Material = Enum.Material.Neon
	effect.CanCollide = false
	effect.Anchored = true
	effect.Position = position

	-- Color based on hit type
	if hitType == "enemy" then
		effect.Color = Color3.fromRGB(255, 100, 100)  -- Red
	else
		effect.Color = Color3.fromRGB(200, 200, 200)  -- Gray
	end

	effect.Parent = workspace

	-- Animate and destroy
	game:GetService("TweenService"):Create(effect,
		TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.1, 0.1, 0.1), Transparency = 1}
	):Play()

	game:GetService("Debris"):AddItem(effect, 0.3)
end

-- Update all active projectiles
function ShootingSystem:startProjectileLoop()
	RunService.Heartbeat:Connect(function(deltaTime)
		for i = #self.activeProjectiles, 1, -1 do
			local projectile = self.activeProjectiles[i]

			-- Check if projectile should be destroyed
			if self:shouldDestroyProjectile(projectile) then
				self:destroyProjectile(i)
				continue
			end

			-- Update projectile physics
			self:updateProjectilePhysics(projectile, deltaTime)
		end
	end)
end

-- Check if projectile should be destroyed
function ShootingSystem:shouldDestroyProjectile(projectile)
	-- Check lifetime
	if tick() - projectile.startTime > projectile.config.lifetime then
		return true
	end

	-- Check if hit something
	if projectile.hasHit then
		return true
	end

	-- Check if part was destroyed
	if not projectile.part.Parent then
		return true
	end

	-- Check if too far below ground
	if projectile.part.Position.Y < -100 then
		return true
	end

	return false
end

-- Update projectile physics
function ShootingSystem:updateProjectilePhysics(projectile, deltaTime)
	-- Apply gravity to the BodyVelocity
	local currentVelocity = projectile.bodyVelocity.Velocity
	local newVelocity = Vector3.new(
		currentVelocity.X,
		currentVelocity.Y + projectile.config.gravity * deltaTime,
		currentVelocity.Z
	)

	projectile.bodyVelocity.Velocity = newVelocity

	-- Debug: Show projectile movement occasionally
	if math.random() < 0.1 then  -- 10% chance to show position
		print("üöÄ Projectile at:", projectile.part.Position, "Velocity:", newVelocity)
	end
end

-- Destroy projectile and clean up
function ShootingSystem:destroyProjectile(index)
	local projectile = self.activeProjectiles[index]

	if projectile then
		-- Disconnect hit detection
		if projectile.hitConnection then
			projectile.hitConnection:Disconnect()
		end

		-- Clean up physics objects
		if projectile.bodyVelocity then
			projectile.bodyVelocity:Destroy()
		end
		if projectile.bodyPosition then
			projectile.bodyPosition:Destroy()
		end

		-- Destroy visual part
		if projectile.part and projectile.part.Parent then
			projectile.part:Destroy()
		end
	end

	-- Remove from active list
	table.remove(self.activeProjectiles, index)
end

-- Get direction name for debugging
function ShootingSystem:getDirectionName(direction)
	local x, z = direction.X, direction.Z
	local threshold = 0.1

	if math.abs(x) < threshold and z < -threshold then return "North"
	elseif math.abs(x) < threshold and z > threshold then return "South"
	elseif x < -threshold and math.abs(z) < threshold then return "West"
	elseif x > threshold and math.abs(z) < threshold then return "East"
	elseif x < -threshold and z < -threshold then return "Northwest"
	elseif x > threshold and z < -threshold then return "Northeast"
	elseif x < -threshold and z > threshold then return "Southwest"
	elseif x > threshold and z > threshold then return "Southeast"
	else return "Center"
	end
end

-- PUBLIC API for changing attacks (future expansion)
function ShootingSystem:setAttack(attackName)
	if ATTACK_CONFIGS[attackName] then
		currentAttack = attackName
		print("üîÑ Attack changed to:", attackName)
		return true
	else
		print("‚ùå Attack not found:", attackName)
		return false
	end
end

function ShootingSystem:getCurrentAttack()
	return currentAttack
end

function ShootingSystem:getAttackConfig(attackName)
	return ATTACK_CONFIGS[attackName or currentAttack]
end

-- Initialize the system
local shootingSystem = ShootingSystem.new()

-- Export for external use
_G.ShootingSystem = shootingSystem

print("üéØ Clean Isaac Shooting System ready!")
print("‚öôÔ∏è Modular design - easy to add new attacks!")
print("üéÆ Zero interference with player movement!")

--[[
üéØ CLEAN ISAAC SHOOTING SYSTEM - FEATURES

‚úÖ ZERO MOVEMENT INTERFERENCE:
- No character rotation manipulation
- No CFrame changes to player
- Purely projectile-based system
- Input tracking only for aim direction

‚úÖ MODULAR ATTACK SYSTEM:
- Easy to add new attack types
- Configurable damage, speed, fire rate
- Visual properties (size, color, effects)
- Physics properties (gravity, lifetime)

‚úÖ SIMPLE PHYSICS:
- Speed affects distance (speed √ó lifetime = range)
- Gravity creates natural arc
- No complex collision systems
- Clean projectile lifecycle

‚úÖ 8-DIRECTIONAL AIMING:
- WASD/Arrow keys for direction
- Diagonal combinations (W+A = NW)
- No character facing changes
- Pure aim direction calculation

‚úÖ RELIABLE HIT DETECTION:
- Touched events (simple and fast)
- Enemy and obstacle detection
- Hit effects and feedback
- Proper cleanup

‚úÖ FUTURE-READY:
- shootingSystem:setAttack("NewAttack")
- Easy to add character-specific attacks
- Configurable everything
- Clean API for expansions

üéÆ Perfect foundation for Isaac-style combat!
--]]
