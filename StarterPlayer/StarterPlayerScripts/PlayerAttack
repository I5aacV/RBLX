-- ========================================================================
-- FIXED ISOMETRIC ATTACK SCRIPT - Y=2 SHOOTING HEIGHT
-- Shoots from Y=2 but hits exact ground coordinates where green ring shows
-- ========================================================================

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- RemoteEvent for server communication
local shootRemote = ReplicatedStorage:FindFirstChild("IsaacShootRemote")
if not shootRemote then
	shootRemote = Instance.new("RemoteEvent")
	shootRemote.Name = "IsaacShootRemote"
	shootRemote.Parent = ReplicatedStorage
end

-- ========================================================================
-- CONFIGURATION
-- ========================================================================

local CONFIG = {
	damage = 10,
	speed = 50,
	fireRate = 0.3,
	maxRange = 20,  -- UPDATED: Max range from character (in studs)
	projectileSize = Vector3.new(1, 1, 1),
	projectileColor = Color3.fromRGB(100, 150, 255),
	shootingHeight = 2,  -- Shooting height from character
	gravityStrength = 50  -- NEW: Gravity effect for bullet drop
}

local lastShotTime = 0
local aimIndicator = nil
local aimLine = nil

-- ========================================================================
-- UTILITIES
-- ========================================================================

-- Raycast from mouse to ground with max range limit
local function getMouseWorldGroundPosition()
	local mousePos = UserInputService:GetMouseLocation()
	local ray = camera:ViewportPointToRay(mousePos.X, mousePos.Y)
	local origin = ray.Origin
	local direction = ray.Direction
	local planeY = 0

	if math.abs(direction.Y) < 1e-4 then return nil end

	local t = (planeY - origin.Y) / direction.Y
	if t < 0 then return nil end

	local worldPos = origin + direction * t

	-- LIMIT TO MAX RANGE from character
	if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		local charPos = player.Character.HumanoidRootPart.Position
		local distance = ((Vector3.new(worldPos.X, 0, worldPos.Z) - Vector3.new(charPos.X, 0, charPos.Z)).Magnitude)

		if distance > CONFIG.maxRange then
			-- Clamp to max range in the same direction
			local direction2D = (Vector3.new(worldPos.X, 0, worldPos.Z) - Vector3.new(charPos.X, 0, charPos.Z)).Unit
			worldPos = Vector3.new(charPos.X, 0, charPos.Z) + direction2D * CONFIG.maxRange
		end
	end

	return worldPos
end

-- Red click debug line
local function spawnDebugLine(position)
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Size = Vector3.new(2, 0.1, 0.2)
	part.Position = Vector3.new(position.X, 0.05, position.Z)
	part.Color = Color3.fromRGB(255, 0, 0)
	part.Material = Enum.Material.Neon
	part.Name = "ClickLine"
	part.Parent = workspace

	if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		local root = player.Character.HumanoidRootPart
		local from = Vector3.new(root.Position.X, 0, root.Position.Z)
		local to = Vector3.new(position.X, 0, position.Z)
		local dir = (to - from).Unit
		part.CFrame = CFrame.new(from:Lerp(to, 0.5), from + dir) * CFrame.Angles(0, math.pi / 2, 0)
	end

	Debris:AddItem(part, 2)
end

-- Green glowing ring
local function createAimIndicator()
	if aimIndicator then return end

	aimIndicator = Instance.new("Part")
	aimIndicator.Anchored = true
	aimIndicator.CanCollide = false
	aimIndicator.Shape = Enum.PartType.Cylinder
	aimIndicator.Size = Vector3.new(4, 0.1, 4)
	aimIndicator.Color = Color3.fromRGB(0, 255, 0)
	aimIndicator.Material = Enum.Material.Neon
	aimIndicator.Name = "AimRing"
	aimIndicator.Parent = workspace

	local light = Instance.new("PointLight")
	light.Color = aimIndicator.Color
	light.Brightness = 2
	light.Range = 6
	light.Parent = aimIndicator
end

local function updateAimIndicator(position)
	if not aimIndicator then createAimIndicator() end
	local pos = Vector3.new(position.X, 0.05, position.Z)
	aimIndicator.Position = pos
	aimIndicator.CFrame = CFrame.new(pos) * CFrame.Angles(math.rad(90), 0, 0)
end

-- Green laser line from player to cursor
local function updateAimLine(from, to)
	if not aimLine then
		aimLine = Instance.new("Part")
		aimLine.Anchored = true
		aimLine.CanCollide = false
		aimLine.Material = Enum.Material.Neon
		aimLine.Color = Color3.fromRGB(0, 255, 0)
		aimLine.Size = Vector3.new(0.15, 0.15, 1)
		aimLine.Name = "AimLine"
		aimLine.Parent = workspace
	end

	local distance = (to - from).Magnitude
	local midpoint = (from + to) / 2
	aimLine.Size = Vector3.new(0.15, 0.15, distance)
	aimLine.CFrame = CFrame.new(midpoint, to)
end

-- ========================================================================
-- PROJECTILE
-- ========================================================================

local function createTravelingProjectile(startPos, initialDirection, targetPos)
	local projectile = Instance.new("Part")
	projectile.Anchored = true
	projectile.CanCollide = false
	projectile.Shape = Enum.PartType.Ball
	projectile.Size = CONFIG.projectileSize
	projectile.Color = CONFIG.projectileColor
	projectile.Material = Enum.Material.Neon
	projectile.Position = startPos
	projectile.Name = "LaserProjectile"
	projectile.Parent = workspace

	-- Enhanced glow effect for prettier visuals
	local light = Instance.new("PointLight")
	light.Color = CONFIG.projectileColor
	light.Brightness = 3
	light.Range = 12
	light.Parent = projectile

	-- Add trailing effect
	local trail = Instance.new("Trail")
	local attachment1 = Instance.new("Attachment")
	local attachment2 = Instance.new("Attachment")
	attachment1.Position = Vector3.new(0, 0, 0.5)
	attachment2.Position = Vector3.new(0, 0, -0.5)
	attachment1.Parent = projectile
	attachment2.Parent = projectile
	trail.Attachment0 = attachment1
	trail.Attachment1 = attachment2
	trail.Color = ColorSequence.new(CONFIG.projectileColor)
	trail.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5),
		NumberSequenceKeypoint.new(1, 1)
	})
	trail.Lifetime = 0.3
	trail.MinLength = 0
	trail.Parent = projectile

	-- Ballistic trajectory calculation
	local startTime = tick()
	local lastPosition = startPos
	local hasHit = false

	-- Calculate initial velocity for ballistic trajectory
	local horizontalDistance = ((Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(startPos.X, 0, startPos.Z)).Magnitude)
	local heightDifference = targetPos.Y - startPos.Y
	local timeToTarget = horizontalDistance / CONFIG.speed

	-- Initial velocity with arc to reach target
	local initialVelocity = Vector3.new(
		(targetPos.X - startPos.X) / timeToTarget,
		(heightDifference / timeToTarget) + (CONFIG.gravityStrength * timeToTarget * 0.5),
		(targetPos.Z - startPos.Z) / timeToTarget
	)

	local connection
	connection = RunService.Heartbeat:Connect(function()
		local elapsed = tick() - startTime

		-- Max lifetime based on time to target + buffer
		if elapsed > timeToTarget + 1 then
			connection:Disconnect()
			if projectile.Parent then projectile:Destroy() end
			return
		end

		-- Ballistic motion with gravity
		local currentVelocity = Vector3.new(
			initialVelocity.X,
			initialVelocity.Y - CONFIG.gravityStrength * elapsed,  -- Apply gravity
			initialVelocity.Z
		)

		local newPos = startPos + Vector3.new(
			initialVelocity.X * elapsed,
			initialVelocity.Y * elapsed - 0.5 * CONFIG.gravityStrength * elapsed * elapsed,  -- Ballistic Y
			initialVelocity.Z * elapsed
		)

		-- Check if projectile hit the ground or target
		if newPos.Y <= targetPos.Y + 0.1 and not hasHit then
			hasHit = true

			-- Hit effect at target position
			local explosion = Instance.new("Explosion")
			explosion.Position = targetPos
			explosion.BlastRadius = 3
			explosion.BlastPressure = 0
			explosion.Parent = workspace

			-- Send hit to server
			shootRemote:FireServer(nil, targetPos, CONFIG.damage, initialDirection)

			-- Clean up projectile
			connection:Disconnect()
			if projectile.Parent then projectile:Destroy() end
			return
		end

		-- Collision detection during flight
		if not hasHit then
			local rayDirection = newPos - lastPosition
			local rayParams = RaycastParams.new()
			rayParams.FilterType = Enum.RaycastFilterType.Blacklist
			rayParams.FilterDescendantsInstances = {
				player.Character,
				projectile,
				workspace:FindFirstChild("Baseplate")
			}

			local result = workspace:Raycast(lastPosition, rayDirection, rayParams)
			if result and result.Instance then
				local hitPart = result.Instance
				if hitPart:IsA("BasePart") and hitPart.Name ~= "Baseplate" then
					local hitPosition = result.Position

					-- Fire hit event to server
					shootRemote:FireServer(hitPart, hitPosition, CONFIG.damage, currentVelocity.Unit)

					-- Visual effect
					local explosion = Instance.new("Explosion")
					explosion.Position = hitPosition
					explosion.BlastRadius = 3
					explosion.BlastPressure = 0
					explosion.Parent = workspace

					hasHit = true
					connection:Disconnect()
					if projectile.Parent then projectile:Destroy() end
					return
				end
			end
		end

		-- Update projectile position
		projectile.Position = newPos
		lastPosition = newPos
	end)
end

-- ========================================================================
-- SHOOT FUNCTION (FIXED FOR Y=2 SHOOTING)
-- ========================================================================

local function shoot()
	local currentTime = tick()
	if currentTime - lastShotTime < CONFIG.fireRate then return end

	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return end

	local root = character.HumanoidRootPart
	local groundTarget = getMouseWorldGroundPosition()
	if not groundTarget then return end

	-- Shooting position at Y=2
	local shootingPos = root.Position + Vector3.new(0, CONFIG.shootingHeight, 0)

	-- Target position on ground (Y=0)
	local targetPos = Vector3.new(groundTarget.X, 0, groundTarget.Z)

	-- Calculate initial direction (for server communication)
	local initialDirection = (targetPos - shootingPos).Unit

	-- Visuals (still show ground targeting)
	updateAimIndicator(groundTarget)
	updateAimLine(Vector3.new(root.Position.X, 0.05, root.Position.Z), Vector3.new(groundTarget.X, 0.05, groundTarget.Z))
	spawnDebugLine(groundTarget)

	-- Create projectile with ballistic trajectory
	createTravelingProjectile(shootingPos, initialDirection, targetPos)

	lastShotTime = currentTime

	print("🎯 Ballistic shot from Y=" .. CONFIG.shootingHeight .. " to range:", 
		math.floor(((targetPos - Vector3.new(root.Position.X, 0, root.Position.Z)).Magnitude)), "studs")
end

-- ========================================================================
-- INPUT + AIM UPDATE
-- ========================================================================

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		shoot()
	end
end)

-- Update aim ring and line each frame
RunService.Heartbeat:Connect(function()
	local target = getMouseWorldGroundPosition()
	if target and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		local root = player.Character.HumanoidRootPart
		local from = Vector3.new(root.Position.X, 0.05, root.Position.Z)
		local to = Vector3.new(target.X, 0.05, target.Z)
		updateAimIndicator(to)
		updateAimLine(from, to)
	end
end)

print("✅ Enhanced Isometric Attack Script Loaded")
print("🎯 Max Range: " .. CONFIG.maxRange .. " studs from character")
print("🌌 Ballistic trajectory with bullet drop enabled")
print("✨ Enhanced visuals: trails, better lighting, and arc motion")
