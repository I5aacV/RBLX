-- ========================================================================
-- REVAMPED ENEMY SPAWNING SYSTEM - Clean & Modular WITH BOSS PEDESTALS
-- Place this in ServerScriptService
-- ========================================================================

local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService") -- FIXED: Added missing import

-- Configuration
local CONFIG = {
	-- Enemy patterns (Isaac-style)
	PATTERNS = {
		FLY_SWARM = {
			name = "Fly Swarm",
			enemies = {"Fly"},
			minCount = 6, maxCount = 10,
			weight = 30
		},
		SPIDER_NEST = {
			name = "Spider Nest",
			enemies = {"Spider"},
			minCount = 3, maxCount = 5,
			weight = 25
		},
		GAPER_HORDE = {
			name = "Gaper Horde",
			enemies = {"Gaper"},
			minCount = 4, maxCount = 7,
			weight = 25
		},
		MIXED_CHAOS = {
			name = "Mixed Chaos",
			enemies = {"Fly", "Spider", "Gaper"},
			minCount = 5, maxCount = 8,
			weight = 10
		}
	},

	-- Room type configurations
	ROOM_CONFIGS = {
		Normal = {usePatterns = true, spawnDelay = 0.2},
		Boss = {usePatterns = false, enemies = {"Boss_Monstro"}, minCount = 1, maxCount = 1},
		Treasure = {usePatterns = false, minCount = 0, maxCount = 0}, -- No enemies
		Shop = {usePatterns = false, minCount = 0, maxCount = 0}, -- No enemies
		Spawn = {usePatterns = false, minCount = 0, maxCount = 0} -- No enemies
	},

	-- Grid configuration (matches your asset system)
	GRID_CELL_SIZE_X = 120 / 13,
	GRID_CELL_SIZE_Z = 80 / 9,
	GRID_WIDTH = 13,
	GRID_HEIGHT = 9
}

-- FIXED: Single BOSS_CONFIG declaration (removed duplicate)
local BOSS_CONFIG = {
	PEDESTAL_SPAWN_DELAY = 2.0, -- Seconds after boss death to spawn pedestal
	PEDESTAL_HEIGHT = 2, -- Height above floor
	BOSS_ITEM_POOLS = {
		-- Guaranteed drops by boss type
		NORMAL_BOSS = {
			pools = {"BOSS_ROOM", "TREASURE_ROOM"}, -- Mix boss and treasure items
			guaranteedRarity = "RARE", -- Minimum rarity
			rarityWeights = {
				RARE = 60,
				LEGENDARY = 30,
				BLESSED = 5,
				CURSED = 5
			}
		},
		MINI_BOSS = {
			pools = {"TREASURE_ROOM"},
			guaranteedRarity = "UNCOMMON",
			rarityWeights = {
				UNCOMMON = 40,
				RARE = 50,
				LEGENDARY = 10
			}
		}
	}
}

-- ========================================================================
-- ENEMY SPAWNER CLASS
-- ========================================================================

local EnemySpawner = {}
EnemySpawner.__index = EnemySpawner

function EnemySpawner.new()
	local self = setmetatable({}, EnemySpawner)
	self.activeRooms = {}
	self.enemyTemplates = {}
	self.roomEnemyCounts = {}
	self.clearedRooms = {}

	self:loadEnemyTemplates()
	self:setupRemoteEvents()

	return self
end

-- ========================================================================
-- BOSS PEDESTAL SYSTEM - Spawns items when bosses are defeated
-- ========================================================================

function EnemySpawner:onBossDefeated(bossModel, roomModel)
	print("üëë BOSS DEFEATED:", bossModel.Name)

	-- Determine boss type
	local bossType = self:getBossType(bossModel)
	local bossConfig = BOSS_CONFIG.BOSS_ITEM_POOLS[bossType]

	if not bossConfig then
		print("‚ùå No boss config found for:", bossType)
		return
	end

	-- Wait a moment for dramatic effect
	task.spawn(function()
		task.wait(BOSS_CONFIG.PEDESTAL_SPAWN_DELAY)
		self:spawnBossPedestal(bossModel, roomModel, bossConfig)
	end)
end

function EnemySpawner:getBossType(bossModel)
	local bossName = string.lower(bossModel.Name)

	-- Check for mini-boss indicators
	if string.find(bossName, "mini") or 
		string.find(bossName, "small") or
		string.find(bossName, "lesser") then
		return "MINI_BOSS"
	end

	-- Default to normal boss
	return "NORMAL_BOSS"
end

function EnemySpawner:spawnBossPedestal(bossModel, roomModel, bossConfig)
	-- Get boss position (where boss died)
	local bossPosition = self:getBossPosition(bossModel)
	if not bossPosition then
		print("‚ùå Could not get boss position")
		return
	end

	-- Select item for pedestal
	local selectedItem = self:selectBossItem(bossConfig)
	if not selectedItem then
		print("‚ùå Could not select boss item")
		return
	end

	-- Calculate pedestal position
	local pedestalPosition = Vector3.new(
		bossPosition.X,
		bossPosition.Y + BOSS_CONFIG.PEDESTAL_HEIGHT,
		bossPosition.Z
	)

	-- Spawn the pedestal with item
	self:createBossPedestal(roomModel, selectedItem, pedestalPosition)

	print("üèÜ Spawned boss pedestal with item:", selectedItem)
end

function EnemySpawner:getBossPosition(bossModel)
	-- Try different ways to get boss position
	if bossModel:FindFirstChild("HumanoidRootPart") then
		return bossModel.HumanoidRootPart.Position
	elseif bossModel:FindFirstChild("Torso") then
		return bossModel.Torso.Position
	elseif bossModel.PrimaryPart then
		return bossModel.PrimaryPart.Position
	else
		-- Find any BasePart in the boss
		for _, child in pairs(bossModel:GetChildren()) do
			if child:IsA("BasePart") then
				return child.Position
			end
		end
	end
	return nil
end

function EnemySpawner:selectBossItem(bossConfig)
	-- Get items from specified pools
	local availableItems = {}

	for _, poolName in pairs(bossConfig.pools) do
		local pool = _G.ItemDatabase.ItemPools[poolName] or {}
		for _, itemId in pairs(pool) do
			local item = _G.ItemDatabase:GetItem(itemId)
			if item and item.unlocked then
				table.insert(availableItems, {id = itemId, item = item})
			end
		end
	end

	-- Filter by minimum rarity
	local guaranteedRarity = bossConfig.guaranteedRarity
	local filteredItems = {}

	for _, itemData in pairs(availableItems) do
		local item = itemData.item
		local itemRarityWeight = _G.ItemDatabase.Rarities[item.rarity].weight or 1
		local minRarityWeight = _G.ItemDatabase.Rarities[guaranteedRarity].weight or 1

		-- Include if rarity is equal or higher (lower weight = higher rarity)
		if itemRarityWeight <= minRarityWeight then
			table.insert(filteredItems, itemData)
		end
	end

	if #filteredItems == 0 then
		print("‚ö†Ô∏è No items meet rarity requirement, using all available")
		filteredItems = availableItems
	end

	-- Apply boss-specific rarity weights
	local weightedItems = {}
	for _, itemData in pairs(filteredItems) do
		local item = itemData.item
		local rarityWeight = bossConfig.rarityWeights[item.rarity] or 1

		-- Add item multiple times based on weight
		for i = 1, rarityWeight do
			table.insert(weightedItems, itemData.id)
		end
	end

	-- Select random item
	if #weightedItems > 0 then
		return weightedItems[math.random(1, #weightedItems)]
	end

	return nil
end

function EnemySpawner:createBossPedestal(roomModel, itemId, position)
	-- Create pedestal base
	local pedestal = Instance.new("Part")
	pedestal.Name = "BossPedestal"
	pedestal.Size = Vector3.new(3, 1, 3)
	pedestal.Position = position
	pedestal.Anchored = true
	pedestal.Material = Enum.Material.Marble
	pedestal.BrickColor = BrickColor.new("Gold")
	pedestal.Parent = roomModel

	-- Add golden glow effect
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 215, 0)
	light.Brightness = 3
	light.Range = 15
	light.Parent = pedestal

	-- Create victory text
	self:createVictoryText(pedestal)

	-- Wait a moment then spawn the item
	task.spawn(function()
		task.wait(1.0) -- Dramatic pause

		-- Spawn item on pedestal
		if _G.ItemSpawner then
			local itemPosition = position + Vector3.new(0, 1.5, 0)
			local spawnedItem = _G.ItemSpawner:spawnItemInRoom(roomModel, itemId, itemPosition)

			if spawnedItem then
				-- Add special boss item effects
				self:addBossItemEffects(spawnedItem)
				print("‚ú® Boss item spawned successfully!")
			end
		else
			warn("‚ùå ItemSpawner not found!")
		end
	end)
end

function EnemySpawner:createVictoryText(pedestal)
	local gui = Instance.new("BillboardGui")
	gui.Name = "VictoryText"
	gui.Size = UDim2.new(0, 200, 0, 50)
	gui.StudsOffset = Vector3.new(0, 2, 0)
	gui.Parent = pedestal

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "üèÜ VICTORY! üèÜ"
	label.TextColor3 = Color3.fromRGB(255, 215, 0)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.TextStrokeTransparency = 0
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.Parent = gui

	-- FIXED: Animate the text (TweenService now imported)
	local scaleTween = TweenService:Create(label, 
		TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
		{TextTransparency = 0.3}
	)
	scaleTween:Play()
end

function EnemySpawner:addBossItemEffects(itemModel)
	-- Add special particle effects for boss items
	local visual = itemModel:FindFirstChild("ItemVisual")
	if not visual then return end

	-- Enhanced glow for boss items
	local existingLight = visual:FindFirstChild("PointLight")
	if existingLight then
		existingLight.Brightness = 4
		existingLight.Range = 20
	end

	-- Add particle effect (if you have particles system)
	-- This is optional enhancement
end

-- ========================================================================
-- TEMPLATE MANAGEMENT
-- ========================================================================

function EnemySpawner:loadEnemyTemplates()
	print("üîç Loading enemy templates...")
	for _, obj in pairs(workspace:GetChildren()) do
		if obj:IsA("Model") and string.find(obj.Name, "EnemyTemplate_") then
			local enemyType = obj.Name:gsub("EnemyTemplate_", "")
			self.enemyTemplates[enemyType] = obj
			obj.Parent = ReplicatedStorage
			print("‚úÖ Loaded enemy:", enemyType)
		end
	end
	print("üëπ Loaded", self:getTemplateCount(), "enemy templates")
end

function EnemySpawner:getTemplateCount()
	local count = 0
	for _ in pairs(self.enemyTemplates) do
		count = count + 1
	end
	return count
end

-- ========================================================================
-- REMOTE EVENTS SETUP
-- ========================================================================

function EnemySpawner:setupRemoteEvents()
	local roomEnterEvent = Instance.new("RemoteEvent")
	roomEnterEvent.Name = "PlayerEnteredRoom"
	roomEnterEvent.Parent = ReplicatedStorage

	roomEnterEvent.OnServerEvent:Connect(function(player, roomID)
		self:onPlayerEnterRoom(roomID)
	end)

	print("üåê Remote events setup complete")
end

-- ========================================================================
-- ROOM DETECTION
-- ========================================================================

function EnemySpawner:findRoomFloor(roomModel)
	for _, child in pairs(roomModel:GetDescendants()) do
		if child:IsA("BasePart") and (
			string.lower(child.Name):find("floor") or
				(child.Size.X >= 100 and child.Size.Z >= 70)
			) then
			return child
		end
	end
	return nil
end

function EnemySpawner:getRoomType(roomModel)
	local name = roomModel.Name or ""
	if string.find(name, "Normal") then return "Normal"
	elseif string.find(name, "Boss") then return "Boss"
	elseif string.find(name, "Treasure") then return "Treasure"
	elseif string.find(name, "Shop") then return "Shop"
	elseif string.find(name, "Spawn") then return "Spawn"
	else return "Normal"
	end
end

function EnemySpawner:getRoomData(roomID)
	-- Try to get from DungeonGenerator first
	if _G.DungeonGenerator and _G.DungeonGenerator.rooms then
		for _, roomData in pairs(_G.DungeonGenerator.rooms) do
			local expectedID = roomData.roomType .. "Room_" .. roomData.gridX .. "_" .. roomData.gridY
			if expectedID == roomID then
				return roomData
			end
		end
	end

	-- Fallback: find room model directly
	local roomModel = workspace:FindFirstChild(roomID)
	if roomModel then
		return {
			model = roomModel,
			roomType = self:getRoomType(roomModel),
			connections = self:detectRoomConnections(roomModel)
		}
	end

	return nil
end

function EnemySpawner:detectRoomConnections(roomModel)
	local connections = {North = false, South = false, East = false, West = false}

	-- Look for ProceduralWalls to detect door openings
	local wallsFolder = roomModel:FindFirstChild("ProceduralWalls")
	if wallsFolder then
		local wallTypes = {"NorthWall", "SouthWall", "EastWall", "WestWall"}
		for _, wallType in pairs(wallTypes) do
			local hasSegments = wallsFolder:FindFirstChild(wallType .. "_Left") or
				wallsFolder:FindFirstChild(wallType .. "_Right")
			if hasSegments then
				if wallType == "NorthWall" then connections.North = true
				elseif wallType == "SouthWall" then connections.South = true
				elseif wallType == "EastWall" then connections.East = true
				elseif wallType == "WestWall" then connections.West = true
				end
			end
		end
	end

	return connections
end

-- ========================================================================
-- PATTERN SELECTION
-- ========================================================================

function EnemySpawner:selectPattern(roomType)
	local config = CONFIG.ROOM_CONFIGS[roomType]
	if not config or not config.usePatterns then
		return {
			enemies = config and config.enemies or {},
			minCount = config and config.minCount or 0,
			maxCount = config and config.maxCount or 0
		}
	end

	-- Calculate total weight
	local totalWeight = 0
	for _, pattern in pairs(CONFIG.PATTERNS) do
		totalWeight = totalWeight + pattern.weight
	end

	-- Select random pattern based on weight
	local randomValue = math.random() * totalWeight
	local currentWeight = 0

	for _, pattern in pairs(CONFIG.PATTERNS) do
		currentWeight = currentWeight + pattern.weight
		if randomValue <= currentWeight then
			print("üéØ Selected pattern:", pattern.name)
			return pattern
		end
	end

	-- Fallback to first pattern
	local firstPattern = next(CONFIG.PATTERNS)
	return firstPattern
end

-- ========================================================================
-- SPAWN POINT GENERATION
-- ========================================================================

function EnemySpawner:generateSpawnPoints(roomData, enemyCount)
	local spawnPoints = {}
	local roomFloor = self:findRoomFloor(roomData.model)
	if not roomFloor then
		warn("‚ùå No floor found for spawning")
		return spawnPoints
	end

	local floorPosition = roomFloor.Position
	local floorSize = roomFloor.Size

	-- Create occupancy grid to avoid assets
	local occupancyGrid = self:createAssetOccupancyGrid(roomData)

	-- Define safe spawn zones
	local safeZones = {
		{x = 0, z = 0, radius = 20}, -- Center
		{x = -15, z = -10, radius = 12}, -- Corners
		{x = 15, z = -10, radius = 12},
		{x = -15, z = 10, radius = 12},
		{x = 15, z = 10, radius = 12}
	}

	for i = 1, enemyCount do
		local attempts = 0
		local validPosition = nil

		while attempts < 30 and not validPosition do
			local zoneIndex = math.min(math.floor(attempts / 5) + 1, #safeZones)
			local zone = safeZones[zoneIndex]
			local angle = math.random() * math.pi * 2
			local distance = math.random() * zone.radius

			local spawnX = floorPosition.X + zone.x + math.cos(angle) * distance
			local spawnZ = floorPosition.Z + zone.z + math.sin(angle) * distance
			local spawnY = floorPosition.Y + floorSize.Y/2 + 3

			local spawnPos = Vector3.new(spawnX, spawnY, spawnZ)

			if self:isPositionSafe(spawnPos, roomFloor, occupancyGrid, spawnPoints) then
				table.insert(spawnPoints, spawnPos)
				validPosition = spawnPos
			end

			attempts = attempts + 1
		end

		if not validPosition then
			print("‚ö†Ô∏è Could not generate safe spawn point", i)
		end
	end

	print("üìç Generated", #spawnPoints, "out of", enemyCount, "spawn points")
	return spawnPoints
end

function EnemySpawner:createAssetOccupancyGrid(roomData)
	local occupancyGrid = {}
	for x = 1, CONFIG.GRID_WIDTH do
		occupancyGrid[x] = {}
		for y = 1, CONFIG.GRID_HEIGHT do
			occupancyGrid[x][y] = false
		end
	end

	local roomFloor = self:findRoomFloor(roomData.model)
	if not roomFloor then return occupancyGrid end

	local floorPosition = roomFloor.Position
	local floorSize = roomFloor.Size

	-- Check for existing assets
	for _, child in pairs(roomData.model:GetDescendants()) do
		if child:IsA("BasePart") and (
			string.find(child.Name, "Rock_") or
				string.find(child.Name, "Spike_") or
				string.find(child.Name, "Pit_") or
				CollectionService:HasTag(child, "RoomObstacle")
			) then
			local gridX, gridY = self:worldToGridCoordinates(child.Position, roomFloor)
			if gridX >= 1 and gridX <= CONFIG.GRID_WIDTH and
				gridY >= 1 and gridY <= CONFIG.GRID_HEIGHT then
				occupancyGrid[gridX][gridY] = true
			end
		end
	end

	return occupancyGrid
end

function EnemySpawner:worldToGridCoordinates(worldPos, roomFloor)
	local floorPosition = roomFloor.Position
	local floorSize = roomFloor.Size

	local gridOriginX = floorPosition.X - floorSize.X / 2 + CONFIG.GRID_CELL_SIZE_X / 2
	local gridOriginZ = floorPosition.Z - floorSize.Z / 2 + CONFIG.GRID_CELL_SIZE_Z / 2

	local gridX = math.floor((worldPos.X - gridOriginX) / CONFIG.GRID_CELL_SIZE_X) + 1
	local gridY = math.floor((worldPos.Z - gridOriginZ) / CONFIG.GRID_CELL_SIZE_Z) + 1

	return gridX, gridY
end

function EnemySpawner:isPositionSafe(worldPos, roomFloor, occupancyGrid, existingSpawns)
	local gridX, gridY = self:worldToGridCoordinates(worldPos, roomFloor)

	-- Check bounds and occupancy
	if gridX < 1 or gridX > CONFIG.GRID_WIDTH or
		gridY < 1 or gridY > CONFIG.GRID_HEIGHT or
		occupancyGrid[gridX][gridY] then
		return false
	end

	-- Check distance from existing spawns
	for _, existingPos in pairs(existingSpawns) do
		if (existingPos - worldPos).Magnitude < 6 then
			return false
		end
	end

	return true
end

-- ========================================================================
-- ENEMY SPAWNING
-- ========================================================================

function EnemySpawner:spawnEnemiesForRoom(roomData)
	if self.activeRooms[roomData] or self.clearedRooms[roomData] then
		print("‚ö†Ô∏è Room already processed")
		return
	end

	local roomType = roomData.roomType
	local pattern = self:selectPattern(roomType)

	if pattern.maxCount == 0 then
		print("üö´ No enemies for", roomType, "room")
		return
	end

	local enemyCount = math.random(pattern.minCount, pattern.maxCount)
	local spawnPoints = self:generateSpawnPoints(roomData, enemyCount)

	if #spawnPoints == 0 then
		print("‚ùå No valid spawn points")
		return
	end

	print("üëπ Spawning", #spawnPoints, "enemies using", pattern.name)

	-- Initialize room tracking
	self.activeRooms[roomData] = {}
	self.roomEnemyCounts[roomData] = 0

	-- Spawn enemies
	for i = 1, #spawnPoints do
		local enemyType = pattern.enemies[math.random(1, #pattern.enemies)]
		self:spawnEnemy(enemyType, spawnPoints[i], roomData)
	end

	-- Lock doors if enemies spawned
	if self.roomEnemyCounts[roomData] > 0 then
		self:lockRoomDoors(roomData)
		print("üîí Locked doors -", self.roomEnemyCounts[roomData], "enemies active")
	end
end

function EnemySpawner:spawnEnemy(enemyType, position, roomData)
	local template = self.enemyTemplates[enemyType]
	if not template then
		warn("‚ùå No template for enemy:", enemyType)
		return
	end
	-- Ensure room tracking exists
	if not self.activeRooms[roomData] then
		self.activeRooms[roomData] = {}
	end
	if not self.roomEnemyCounts[roomData] then
		self.roomEnemyCounts[roomData] = 0
	end
	-- Clone and position enemy
	local enemy = template:Clone()
	enemy.Name = enemyType .. "_" .. tick()
	enemy.Parent = roomData.model
	self:positionEnemy(enemy, position)

	-- ADD THIS: Disable Humanoid physics control for immediate response
	local humanoid = enemy:FindFirstChild("Humanoid")
	if humanoid then
		humanoid.PlatformStand = true  -- Prevents Humanoid from controlling physics
		print("üîß Disabled physics control for:", enemy.Name)
	else
		warn("‚ö†Ô∏è No Humanoid found in enemy:", enemy.Name)
	end

	-- Add to tracking
	table.insert(self.activeRooms[roomData], enemy)
	self.roomEnemyCounts[roomData] = self.roomEnemyCounts[roomData] + 1
	-- Setup tags and attributes
	CollectionService:AddTag(enemy, "RoomEnemy")
	enemy:SetAttribute("RoomID", roomData.roomType .. "Room_" .. (roomData.gridX or 1) .. "_" .. (roomData.gridY or 1))
	-- Setup death detection
	self:setupEnemyDeathDetection(enemy, roomData)
	print("üëπ Spawned", enemyType, "at", position)
end

function EnemySpawner:positionEnemy(enemy, position)
	if enemy.PrimaryPart then
		enemy:SetPrimaryPartCFrame(CFrame.new(position))
	elseif enemy:FindFirstChild("HumanoidRootPart") then
		enemy.HumanoidRootPart.Position = position
	else
		-- Fallback positioning
		local mainPart = enemy:FindFirstChildOfClass("BasePart")
		if mainPart then
			local offset = position - mainPart.Position
			for _, part in pairs(enemy:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Position = part.Position + offset
				end
			end
		end
	end
end

function EnemySpawner:setupEnemyDeathDetection(enemy, roomData)
	local humanoid = enemy:FindFirstChild("Humanoid")
	if not humanoid then
		warn("‚ùå No Humanoid found in enemy:", enemy.Name)
		return
	end

	print("üîó Setting up IMMEDIATE death detection for:", enemy.Name)

	-- Create a single, robust death handler
	local function handleDeath()
		-- ROBUST duplicate prevention using enemy instance
		if enemy:GetAttribute("DeathProcessed") then
			print("üö´ Death already processed for:", enemy.Name)
			return
		end
		enemy:SetAttribute("DeathProcessed", true)
		print("üíÄ DEATH CONFIRMED for:", enemy.Name)
		self:onEnemyDied(enemy, roomData)
	end

	-- PRIMARY: Use Died event (most reliable)
	local diedConnection = humanoid.Died:Connect(handleDeath)

	-- IMPROVED BACKUP: IMMEDIATE health monitoring (NO DELAY)
	local healthConnection = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
		if humanoid.Health <= 0 and not enemy:GetAttribute("DeathProcessed") then
			print("ü©∏ Health reached 0, IMMEDIATE death trigger for:", enemy.Name)
			-- NO DELAY - process immediately for instant room clearing
			handleDeath()
		end
	end)

	-- BACKUP 2: Monitor for enemy destruction
	local ancestryConnection = enemy.AncestryChanged:Connect(function()
		if not enemy.Parent and not enemy:GetAttribute("DeathProcessed") then
			print("üóëÔ∏è Enemy destroyed, triggering death for:", enemy.Name)
			handleDeath()
		end
	end)

	-- Store connections for cleanup
	enemy:SetAttribute("DeathConnectionsSet", true)

	print("‚úÖ IMMEDIATE death detection setup complete for:", enemy.Name)
end

function EnemySpawner:isBossEnemy(enemy)
	local enemyName = string.lower(enemy.Name)

	-- Check for boss indicators in name
	if string.find(enemyName, "boss") or
		string.find(enemyName, "monstro") or
		string.find(enemyName, "duke") or
		string.find(enemyName, "larry") then
		return true
	end

	-- Check if enemy is in a boss room
	local roomModel = enemy.Parent
	if roomModel and string.find(string.lower(roomModel.Name), "boss") then
		return true
	end

	return false
end

-- REPLACE THIS FUNCTION: onEnemyDied
function EnemySpawner:onEnemyDied(enemy, roomData)
	print("üî• Processing enemy death:", enemy.Name)

	-- Additional safety check
	if enemy:GetAttribute("DeathProcessed") and enemy:GetAttribute("CounterProcessed") then
		print("üö´ Counter already processed for:", enemy.Name)
		return
	end
	enemy:SetAttribute("CounterProcessed", true)

	-- Validate room data exists
	if not self.roomEnemyCounts[roomData] then
		print("‚ùå No counter data for room, cannot process death")
		return
	end

	-- Validate enemy was actually tracked
	local wasTracked = false
	if self.activeRooms[roomData] then
		for i = #self.activeRooms[roomData], 1, -1 do
			if self.activeRooms[roomData][i] == enemy then
				table.remove(self.activeRooms[roomData], i)
				wasTracked = true
				print("‚úÖ Removed enemy from tracking list")
				break
			end
		end
	end

	if not wasTracked then
		print("‚ö†Ô∏è Enemy death detected but enemy wasn't in tracking list:", enemy.Name)
		print("‚ö†Ô∏è This might indicate a double-death or tracking error")
		-- Don't return - still decrement counter as enemy clearly died
	end

	-- Update counter with validation
	if self.roomEnemyCounts[roomData] > 0 then
		self.roomEnemyCounts[roomData] = self.roomEnemyCounts[roomData] - 1
		local remaining = self.roomEnemyCounts[roomData]
		print("üíÄ", enemy.Name, "died | Remaining enemies:", remaining)

		-- Check if room is cleared
		if remaining <= 0 then
			print("üéâ ALL ENEMIES DEFEATED! Room cleared!")
			self:onRoomCleared(roomData)
		end
	else
		print("‚ùå Counter was already 0! This indicates a serious counting error.")
		print("‚ùå Room:", roomData.roomType, "Counter:", self.roomEnemyCounts[roomData])
		-- Force clear the room anyway since an enemy definitely died
		self:onRoomCleared(roomData)
	end
end


-- ADD THIS NEW FUNCTION: debugEnemyCounters
function EnemySpawner:debugEnemyCounters()
	print("=== üîç ENEMY COUNTER DEBUG ===")
	local totalActiveRooms = 0
	local totalEnemies = 0

	for roomData, count in pairs(self.roomEnemyCounts) do
		if count > 0 then
			totalActiveRooms = totalActiveRooms + 1
			totalEnemies = totalEnemies + count

			print("üè† Room:", roomData.roomType, "| Counter:", count)

			-- Check tracked enemies
			if self.activeRooms[roomData] then
				local trackedCount = #self.activeRooms[roomData]
				print("  üìä Tracked enemies:", trackedCount)

				if trackedCount ~= count then
					print("  ‚ö†Ô∏è MISMATCH! Counter says", count, "but tracking", trackedCount)
				end

				-- List each enemy with health
				for i, enemy in ipairs(self.activeRooms[roomData]) do
					local humanoid = enemy:FindFirstChild("Humanoid")
					local health = humanoid and humanoid.Health or "No Humanoid"
					local processed = enemy:GetAttribute("DeathProcessed") and "DEAD" or "ALIVE"
					print("    ", i, enemy.Name, "Health:", health, "Status:", processed)
				end
			else
				print("  ‚ùå No tracking data for room with", count, "enemies!")
			end
			print("") -- Empty line for readability
		end
	end

	print("üìà SUMMARY:", totalActiveRooms, "active rooms,", totalEnemies, "total enemies")
	print("=== END DEBUG ===")
end

-- ADD THIS NEW FUNCTION: forceFixCounters (emergency repair)
function EnemySpawner:forceFixCounters()
	print("üö® FORCE FIXING ENEMY COUNTERS...")

	for roomData, count in pairs(self.roomEnemyCounts) do
		if self.activeRooms[roomData] then
			-- Count actually alive enemies
			local aliveCount = 0
			for i = #self.activeRooms[roomData], 1, -1 do
				local enemy = self.activeRooms[roomData][i]
				local humanoid = enemy:FindFirstChild("Humanoid")

				if humanoid and humanoid.Health > 0 and enemy.Parent then
					aliveCount = aliveCount + 1
				else
					-- Remove dead enemy from tracking
					table.remove(self.activeRooms[roomData], i)
					print("üßπ Removed dead enemy from tracking:", enemy.Name)
				end
			end

			-- Fix the counter
			if aliveCount ~= count then
				print("üîß Fixed counter for", roomData.roomType, "from", count, "to", aliveCount)
				self.roomEnemyCounts[roomData] = aliveCount

				-- Check if room should be cleared
				if aliveCount <= 0 then
					print("üéâ Room cleared after counter fix!")
					self:onRoomCleared(roomData)
				end
			end
		end
	end

	print("‚úÖ Counter repair complete!")
end

function EnemySpawner:onRoomCleared(roomData)
	print("üéâ ROOM CLEARED!", roomData.roomType, "room")

	-- Mark room as cleared
	self.clearedRooms[roomData] = true
	self.activeRooms[roomData] = nil
	self.roomEnemyCounts[roomData] = nil

	-- Unlock doors
	self:unlockRoomDoors(roomData)

	-- Trigger any room clear effects
	if _G.ItemEffects then
		for _, player in pairs(Players:GetPlayers()) do
			_G.ItemEffects:OnRoomCleared(player)
		end
	end
end

-- ========================================================================
-- DOOR MANAGEMENT
-- ========================================================================

function EnemySpawner:lockRoomDoors(roomData)
	print("üîí Locking doors for", roomData.roomType, "room")

	-- Use SharedDoorManager if available
	if _G.SharedDoorManager then
		_G.SharedDoorManager:lockRoomDoors(roomData.model)
		return
	end

	-- Fallback: Create manual barriers
	self:createDoorBarriers(roomData)
end

function EnemySpawner:unlockRoomDoors(roomData)
	print("üîì Unlocking doors for", roomData.roomType, "room")

	-- Use SharedDoorManager if available
	if _G.SharedDoorManager then
		_G.SharedDoorManager:unlockRoomDoors(roomData.model)
		return
	end

	-- Fallback: Remove manual barriers
	self:removeDoorBarriers(roomData)
end

function EnemySpawner:createDoorBarriers(roomData)
	local roomFloor = self:findRoomFloor(roomData.model)
	if not roomFloor then return end

	local floorPosition = roomFloor.Position
	local floorSize = roomFloor.Size

	local barriersFolder = Instance.new("Folder")
	barriersFolder.Name = "EnemyBarriers"
	barriersFolder.Parent = roomData.model

	-- Create barriers for each connection
	local connections = roomData.connections or {}
	if connections.North then
		self:createBarrier(barriersFolder, "North",
			floorPosition + Vector3.new(0, 6, -floorSize.Z/2 - 1),
			Vector3.new(12, 12, 2))
	end
	if connections.South then
		self:createBarrier(barriersFolder, "South",
			floorPosition + Vector3.new(0, 6, floorSize.Z/2 + 1),
			Vector3.new(12, 12, 2))
	end
	if connections.East then
		self:createBarrier(barriersFolder, "East",
			floorPosition + Vector3.new(floorSize.X/2 + 1, 6, 0),
			Vector3.new(2, 12, 12))
	end
	if connections.West then
		self:createBarrier(barriersFolder, "West",
			floorPosition + Vector3.new(-floorSize.X/2 - 1, 6, 0),
			Vector3.new(2, 12, 12))
	end
end

function EnemySpawner:createBarrier(parent, direction, position, size)
	local barrier = Instance.new("Part")
	barrier.Name = direction .. "Barrier"
	barrier.Size = size
	barrier.Position = position
	barrier.Anchored = true
	barrier.CanCollide = true
	barrier.BrickColor = BrickColor.new("Really black")
	barrier.Material = Enum.Material.Concrete
	barrier.Parent = parent

	-- Add warning text
	local gui = Instance.new("SurfaceGui")
	gui.Face = Enum.NormalId.Front
	gui.Parent = barrier

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "üö´ CLEAR ENEMIES üö´"
	label.TextColor3 = Color3.new(1, 0, 0)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.Parent = gui
end

function EnemySpawner:removeDoorBarriers(roomData)
	local barriersFolder = roomData.model:FindFirstChild("EnemyBarriers")
	if barriersFolder then
		-- Flash green briefly
		for _, barrier in pairs(barriersFolder:GetChildren()) do
			if barrier:IsA("BasePart") then
				barrier.BrickColor = BrickColor.new("Bright green")
				local gui = barrier:FindFirstChild("SurfaceGui")
				if gui then
					local label = gui:FindFirstChild("TextLabel")
					if label then
						label.Text = "‚úÖ ROOM CLEARED! ‚úÖ"
						label.TextColor3 = Color3.new(0, 1, 0)
					end
				end
			end
		end

		-- Remove after delay
		game:GetService("Debris"):AddItem(barriersFolder, 1.0)
	end
end

-- ========================================================================
-- PUBLIC API
-- ========================================================================

function EnemySpawner:onPlayerEnterRoom(roomID)
	local roomData = self:getRoomData(roomID)
	if roomData then
		print("üö™ Player entered room:", roomID)
		self:spawnEnemiesForRoom(roomData)
	else
		print("‚ö†Ô∏è Could not find room data for:", roomID)
	end
end

function EnemySpawner:getAliveEnemyCount(roomData)
	return self.roomEnemyCounts[roomData] or 0
end

function EnemySpawner:getTotalAliveEnemyCount()
	local total = 0
	for _, count in pairs(self.roomEnemyCounts) do
		total = total + count
	end
	return total
end

function EnemySpawner:printEnemyStatus()
	local total = self:getTotalAliveEnemyCount()
	print("üëπ ENEMY STATUS:")
	print(" Total alive:", total)
	print(" Active rooms:", self:getActiveRoomCount())
	print(" Cleared rooms:", self:getClearedRoomCount())
	if total > 0 then
		for roomData, count in pairs(self.roomEnemyCounts) do
			if count > 0 then
				print(" Room", roomData.roomType, ":", count, "enemies")
			end
		end
	end
end

function EnemySpawner:getActiveRoomCount()
	local count = 0
	for _ in pairs(self.activeRooms) do
		count = count + 1
	end
	return count
end

function EnemySpawner:getClearedRoomCount()
	local count = 0
	for _ in pairs(self.clearedRooms) do
		count = count + 1
	end
	return count
end

function EnemySpawner:forceSpawnInRoom(roomModel, enemyType, position)
	local roomData = {
		model = roomModel,
		roomType = self:getRoomType(roomModel),
		connections = self:detectRoomConnections(roomModel)
	}

	if not self.activeRooms[roomData] then
		self.activeRooms[roomData] = {}
		self.roomEnemyCounts[roomData] = 0
	end

	return self:spawnEnemy(enemyType, position, roomData)
end

function EnemySpawner:clearRoom(roomData)
	if self.activeRooms[roomData] then
		for _, enemy in pairs(self.activeRooms[roomData]) do
			if enemy.Parent then
				local humanoid = enemy:FindFirstChild("Humanoid")
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	end
end

function EnemySpawner:clearAllRooms()
	for roomData, _ in pairs(self.activeRooms) do
		self:clearRoom(roomData)
	end
end

-- ========================================================================
-- TESTING FUNCTIONS (ADDED BACK)
-- ========================================================================

-- FIXED: Added missing test function
function EnemySpawner:testBossPedestal()
	print("üß™ Testing boss pedestal system...")

	-- Find any room to test in
	for _, roomData in pairs(self.activeRooms) do
		local testConfig = BOSS_CONFIG.BOSS_ITEM_POOLS.NORMAL_BOSS
		local roomFloor = self:findRoomFloor(roomData.model)
		local testPosition = roomFloor and roomFloor.Position + Vector3.new(0, 5, 0) or Vector3.new(0, 5, 0)

		self:createBossPedestal(roomData.model, "magic_mushroom", testPosition)
		print("üß™ Test boss pedestal spawned in active room!")
		return
	end

	-- If no active rooms, try to find any room in workspace
	for _, obj in pairs(workspace:GetChildren()) do
		if obj:IsA("Model") and string.find(obj.Name, "Room") then
			local roomFloor = self:findRoomFloor(obj)
			local testPosition = roomFloor and roomFloor.Position + Vector3.new(0, 5, 0) or Vector3.new(0, 5, 0)

			self:createBossPedestal(obj, "magic_mushroom", testPosition)
			print("üß™ Test boss pedestal spawned in", obj.Name)
			return
		end
	end

	print("‚ùå No rooms found for testing!")
end

-- Test function for spawning a boss enemy
function EnemySpawner:testBossSpawn(roomName)
	local roomModel = workspace:FindFirstChild(roomName)
	if not roomModel then
		print("‚ùå Room not found:", roomName)
		print("Available rooms:")
		for _, obj in pairs(workspace:GetChildren()) do
			if obj:IsA("Model") and string.find(obj.Name, "Room") then
				print(" -", obj.Name)
			end
		end
		return
	end

	local floor = self:findRoomFloor(roomModel)
	if not floor then
		print("‚ùå No floor found in room")
		return
	end

	local spawnPosition = floor.Position + Vector3.new(0, 5, 0)

	-- Create a test boss enemy
	local testBoss = Instance.new("Model")
	testBoss.Name = "EnemyTemplate_Boss_TestBoss"
	testBoss.Parent = roomModel

	-- Create humanoid and parts
	local humanoid = Instance.new("Humanoid")
	humanoid.MaxHealth = 100
	humanoid.Health = 100
	humanoid.Parent = testBoss

	local rootPart = Instance.new("Part")
	rootPart.Name = "HumanoidRootPart"
	rootPart.Size = Vector3.new(4, 4, 4)
	rootPart.Position = spawnPosition
	rootPart.BrickColor = BrickColor.new("Really red")
	rootPart.Material = Enum.Material.Neon
	rootPart.Anchored = true
	rootPart.Parent = testBoss

	-- Add boss tag
	CollectionService:AddTag(testBoss, "RoomEnemy")

	-- Setup death detection
	local roomData = {
		model = roomModel,
		roomType = self:getRoomType(roomModel),
		connections = self:detectRoomConnections(roomModel)
	}

	self:setupEnemyDeathDetection(testBoss, roomData)

	print("üß™ Test boss spawned in", roomName, "!")
	print("üí° Kill it with: workspace." .. roomName .. ".EnemyTemplate_Boss_TestBoss.Humanoid.Health = 0")
	print("üèÜ This should trigger the boss pedestal system!")
end

-- Test function to simulate boss defeat without spawning
function EnemySpawner:testBossDefeat(roomName)
	local roomModel = workspace:FindFirstChild(roomName)
	if not roomModel then
		print("‚ùå Room not found:", roomName)
		return
	end

	-- Create fake boss for testing
	local fakeBoss = Instance.new("Model")
	fakeBoss.Name = "Boss_TestDefeat"

	local fakePart = Instance.new("Part")
	fakePart.Name = "HumanoidRootPart"
	fakePart.Size = Vector3.new(1, 1, 1)
	fakePart.Position = Vector3.new(0, 0, 0)
	fakePart.Parent = fakeBoss

	-- Trigger boss defeat directly
	self:onBossDefeated(fakeBoss, roomModel)

	print("üß™ Simulated boss defeat in", roomName)
	print("üèÜ Boss pedestal should spawn in 2 seconds!")
end

-- ========================================================================
-- INITIALIZATION
-- ========================================================================

local enemySpawner = EnemySpawner.new()

-- Export globally
_G.EnemySpawner = enemySpawner


-- Connect to player cleanup
Players.PlayerRemoving:Connect(function(player)
	-- Clean up any player-specific data if needed
end)

print("üéÆ Revamped Enemy Spawning System with Boss Pedestals loaded!")
print("üìã Features:")
print(" ‚úÖ Isaac-style enemy patterns")
print(" ‚úÖ Asset avoidance system") 
print(" ‚úÖ Instant death detection")
print(" ‚úÖ Automatic door locking/unlocking")
print(" ‚úÖ Room clearing detection")
print(" ‚úÖ Integration with existing systems")
print(" üëë Boss pedestal system with golden effects")
print(" üèÜ Weighted rarity drops for boss defeats")
print("")
print("üîß Console Commands:")
print(" _G.EnemySpawner:printEnemyStatus()")
print(" _G.EnemySpawner:clearAllRooms()")
print(" _G.EnemySpawner:forceSpawnInRoom(roomModel, 'Fly', position)")
print("")
print("üß™ Boss Testing Commands:")
print(" _G.EnemySpawner:testBossPedestal() -- Test pedestal spawn")
print(" _G.EnemySpawner:testBossSpawn('RoomName') -- Spawn killable test boss")
print(" _G.EnemySpawner:testBossDefeat('RoomName') -- Simulate boss defeat")
print("")
print("üëë Boss Pedestal System Features:")
print(" ‚úÖ Automatic boss defeat detection")
print(" ‚úÖ 2-second dramatic delay before pedestal spawn")
print(" ‚úÖ Golden pedestal with animated victory text")
print(" ‚úÖ Guaranteed rare+ items (60% Rare, 30% Legendary, 10% Blessed/Cursed)")
print(" ‚úÖ Enhanced glow effects for boss items")
print(" ‚úÖ Integration with ItemSpawner system")
print(" ‚úÖ Works with ItemDatabase rarity system")

return enemySpawner
