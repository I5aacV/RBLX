-- ========================================================================
-- ENHANCED DEATH DETECTOR - Preserves Your Counter/Debug System  
-- ModuleScript in ReplicatedStorage/Modules/EnhancedDeathDetector
-- ========================================================================

local EnhancedDeathDetector = {}

function EnhancedDeathDetector.new()
	local self = {}
	self.trackedEnemies = {}
	self.performanceStats = {
		totalDetections = 0,
		immediateDetections = 0,
		backupDetections = 0,
		failedDetections = 0
	}

	function self:trackEnemy(enemy, onDeathCallback, roomData)
		local humanoid = enemy:FindFirstChild("Humanoid")
		if not humanoid then
			warn("‚ùå No Humanoid in enemy:", enemy.Name)
			return false
		end

		print("üîó Setting up IMMEDIATE death detection for:", enemy.Name)

		-- Enhanced tracking data
		local trackingData = {
			enemy = enemy,
			humanoid = humanoid,
			roomData = roomData,
			onDeathCallback = onDeathCallback,
			connections = {},
			isProcessed = false,
			startTime = tick(),
			healthChecks = 0
		}

		-- Setup multiple detection methods for reliability
		self:setupPrimaryDetection(trackingData)
		self:setupBackupDetection(trackingData)

		self.trackedEnemies[enemy] = trackingData
		return true
	end

	function self:setupPrimaryDetection(trackingData)
		local enemy = trackingData.enemy
		local humanoid = trackingData.humanoid

		-- PRIMARY: Died event (most reliable)
		local diedConnection = humanoid.Died:Connect(function()
			self:handleDeath(trackingData, "DIED_EVENT")
		end)

		table.insert(trackingData.connections, diedConnection)
	end

	function self:setupBackupDetection(trackingData)
		local enemy = trackingData.enemy
		local humanoid = trackingData.humanoid

		-- BACKUP 1: Immediate health monitoring (from YOUR system)
		local healthConnection = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
			if humanoid.Health <= 0 and not trackingData.isProcessed then
				print("ü©∏ Health reached 0, IMMEDIATE death trigger for:", enemy.Name)
				self:handleDeath(trackingData, "HEALTH_MONITOR")
			end
		end)

		table.insert(trackingData.connections, healthConnection)

		-- BACKUP 2: Destruction monitoring (from YOUR system)
		local ancestryConnection = enemy.AncestryChanged:Connect(function()
			if not enemy.Parent and not trackingData.isProcessed then
				print("üóëÔ∏è Enemy destroyed, triggering death for:", enemy.Name)
				self:handleDeath(trackingData, "DESTROYED")
			end
		end)

		table.insert(trackingData.connections, ancestryConnection)
	end

	function self:handleDeath(trackingData, detectionMethod)
		local enemy = trackingData.enemy

		-- Robust duplicate prevention (from YOUR system)
		if trackingData.isProcessed then
			print("üö´ Death already processed for:", enemy.Name)
			return
		end

		trackingData.isProcessed = true
		enemy:SetAttribute("DeathProcessed", true)

		print("üíÄ DEATH CONFIRMED for:", enemy.Name, "via", detectionMethod)

		-- Update performance stats (YOUR debug system)
		self:updatePerformanceStats(detectionMethod)

		-- Execute death callback
		if trackingData.onDeathCallback then
			local success, err = pcall(trackingData.onDeathCallback, enemy, trackingData.roomData)
			if not success then
				warn("‚ùå Death callback failed for:", enemy.Name, "Error:", err)
				self.performanceStats.failedDetections = self.performanceStats.failedDetections + 1
			end
		end

		-- Clean up tracking
		self:stopTracking(enemy)

		print("‚úÖ Death processing complete for:", enemy.Name)
	end

	function self:updatePerformanceStats(detectionMethod)
		self.performanceStats.totalDetections = self.performanceStats.totalDetections + 1

		if detectionMethod == "DIED_EVENT" or detectionMethod == "HEALTH_MONITOR" then
			self.performanceStats.immediateDetections = self.performanceStats.immediateDetections + 1
		else
			self.performanceStats.backupDetections = self.performanceStats.backupDetections + 1
		end
	end

	function self:stopTracking(enemy)
		local trackingData = self.trackedEnemies[enemy]
		if not trackingData then return end

		-- Disconnect all connections
		for _, connection in pairs(trackingData.connections) do
			if connection then
				connection:Disconnect()
			end
		end

		self.trackedEnemies[enemy] = nil
	end

	function self:getTrackedEnemyCount()
		local count = 0
		for _ in pairs(self.trackedEnemies) do
			count = count + 1
		end
		return count
	end

	-- YOUR debug functions preserved
	function self:debugTrackedEnemies()
		print("=== üíÄ DEATH DETECTOR DEBUG ===")
		print("üìä Tracked enemies:", self:getTrackedEnemyCount())
		print("üìà Performance stats:")
		print("  Total detections:", self.performanceStats.totalDetections)
		print("  Immediate detections:", self.performanceStats.immediateDetections)
		print("  Backup detections:", self.performanceStats.backupDetections)
		print("  Failed detections:", self.performanceStats.failedDetections)

		if self:getTrackedEnemyCount() > 0 then
			print("üìã Currently tracked:")
			for enemy, trackingData in pairs(self.trackedEnemies) do
				local health = trackingData.humanoid.Health
				local checks = trackingData.healthChecks
				local alive = health > 0 and "ALIVE" or "DEAD"
				local processed = trackingData.isProcessed and "PROCESSED" or "ACTIVE"

				print("  ", enemy.Name, "Health:", health, "Status:", alive, "State:", processed, "Checks:", checks)
			end
		end
		print("=== END DEBUG ===")
	end

	function self:forceProcessDead()
		print("üö® Force processing all dead enemies...")

		local processed = 0
		for enemy, trackingData in pairs(self.trackedEnemies) do
			if trackingData.humanoid.Health <= 0 and not trackingData.isProcessed then
				print("üîß Force processing:", enemy.Name)
				self:handleDeath(trackingData, "FORCE_PROCESS")
				processed = processed + 1
			end
		end

		print("‚úÖ Force processed", processed, "dead enemies")
		return processed
	end

	function self:getPerformanceStats()
		return self.performanceStats
	end

	return self
end

return EnhancedDeathDetector
